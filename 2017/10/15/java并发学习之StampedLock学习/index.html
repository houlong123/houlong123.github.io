<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>java并发学习之StampedLock学习 | 而今伊始，命途自闯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 ReentrantReadWriteLock源码学习 中，学习了读写锁的源码实现。但是在 读多写少 的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程迟迟无法竞争到锁而一直处于等待状态。StampedLock锁是对ReentrantReadWriteLock锁的一">
<meta name="keywords" content="java并发锁">
<meta property="og:type" content="article">
<meta property="og:title" content="java并发学习之StampedLock学习">
<meta property="og:url" content="https://houlong123.github.io/2017/10/15/java并发学习之StampedLock学习/index.html">
<meta property="og:site_name" content="而今伊始，命途自闯">
<meta property="og:description" content="前言&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 ReentrantReadWriteLock源码学习 中，学习了读写锁的源码实现。但是在 读多写少 的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程迟迟无法竞争到锁而一直处于等待状态。StampedLock锁是对ReentrantReadWriteLock锁的一">
<meta property="og:updated_time" content="2018-01-25T08:13:54.344Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java并发学习之StampedLock学习">
<meta name="twitter:description" content="前言&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 ReentrantReadWriteLock源码学习 中，学习了读写锁的源码实现。但是在 读多写少 的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程迟迟无法竞争到锁而一直处于等待状态。StampedLock锁是对ReentrantReadWriteLock锁的一">
  
    <link rel="alternate" href="/atom.xml" title="而今伊始，命途自闯" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">而今伊始，命途自闯</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://houlong123.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-java并发学习之StampedLock学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/15/java并发学习之StampedLock学习/" class="article-date">
  <time datetime="2017-10-15T06:33:39.000Z" itemprop="datePublished">2017-10-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      java并发学习之StampedLock学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在 <a href="https://houlong123.github.io/2017/09/28/java并发学习之ReentrantReadWriteLock学习/">ReentrantReadWriteLock源码学习</a> 中，学习了读写锁的源码实现。但是在 <font color="red"><code>读多写少</code></font> 的情况下，使用 ReentrantReadWriteLock 可能会使写入线程遭遇饥饿（Starvation）问题，也就是写入线程迟迟无法竞争到锁而一直处于等待状态。<code>StampedLock锁是对ReentrantReadWriteLock锁的一种改进，即StampedLock是一种改进的读写锁</code>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; StampedLock锁有三种模式：写，读，乐观读。StampedLock锁的<code>状态是由版本和模式两个部分组成</code>，锁获取方法返回一个数字作为票据stamp，它用相应的锁状态表示并控制访问。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">double</span> x, y;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> StampedLock sl = <span class="keyword">new</span> StampedLock();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> deltaX, <span class="keyword">double</span> deltaY)</span> </span>&#123; <span class="comment">// an exclusively locked method</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * stampedLock调用writeLock和unlockWrite时候都会导致stampedLock的state（锁状态）属性值的变化</span></span><br><span class="line"><span class="comment">        * 即每次高8位 +1，直到加到最大值，然后从0重新开始. </span></span><br><span class="line"><span class="comment">        * 当锁被写模式所占有，没有读或者乐观的读操作能够成功。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">     <span class="keyword">long</span> stamp = sl.writeLock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       x += deltaX;</span><br><span class="line">       y += deltaY;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">//释放写锁</span></span><br><span class="line">       sl.unlockWrite(stamp);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">distanceFromOrigin</span><span class="params">()</span> </span>&#123; <span class="comment">// A read-only method</span></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * tryOptimisticRead是一个乐观的读，使用这种锁的读不阻塞写</span></span><br><span class="line"><span class="comment">        * 每次读的时候得到一个当前的stamp值</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">     <span class="keyword">long</span> stamp = sl.tryOptimisticRead();</span><br><span class="line">     <span class="keyword">double</span> currentX = x, currentY = y;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * validate()方法校验从调用tryOptimisticRead()之后有没有线程获得写锁，</span></span><br><span class="line"><span class="comment">      *     true:无写锁，state与stamp匹配</span></span><br><span class="line"><span class="comment">      *     false:有写锁，state与stamp不匹配，或者stamp=0（调用tryOptimisticRead()时已经被其他线程持有写锁）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">if</span> (!sl.validate(stamp)) &#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 被写锁入侵需要使用悲观读锁重读，阻塞写锁（防止再次出现脏数据） 或者 等待写锁释放锁</span></span><br><span class="line"><span class="comment">          * 当然重读的时候还可以使用tryOptimisticRead，此时需要结合循环了，即类似CAS方式</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        stamp = sl.readLock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          currentX = x;</span><br><span class="line">          currentY = y;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//释放读锁</span></span><br><span class="line">           sl.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> (currentX +  currentY);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化 x,y</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newX</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> newY</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveIfAtOrigin</span><span class="params">(<span class="keyword">double</span> newX, <span class="keyword">double</span> newY)</span> </span>&#123; </span><br><span class="line">     <span class="comment">// 以乐观读锁的方式开始，而不是悲观读锁</span></span><br><span class="line">     <span class="keyword">long</span> stamp = sl.readLock();</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">while</span> (x == <span class="number">0.0</span> &amp;&amp; y == <span class="number">0.0</span>) &#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 尝试转换成写锁</span></span><br><span class="line"><span class="comment">          *     0：获得写锁失败</span></span><br><span class="line"><span class="comment">          *     非0：获得写锁成功</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">         <span class="keyword">long</span> ws = sl.tryConvertToWriteLock(stamp);</span><br><span class="line">         <span class="comment">//持有写锁</span></span><br><span class="line">         <span class="keyword">if</span> (ws != <span class="number">0L</span>) &#123;</span><br><span class="line">           stamp = ws;</span><br><span class="line">           x = newX;</span><br><span class="line">           y = newY;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//否则调用writeLock()直到获得写锁</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">           sl.unlockRead(stamp);</span><br><span class="line">           stamp = sl.writeLock();</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">//释放锁，可以是writeLock，也可是readLock</span></span><br><span class="line">         sl.unlock(stamp);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><h5 id="内部数据结构"><a href="#内部数据结构" class="headerlink" title="内部数据结构"></a>内部数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLock</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** Number of processors, for spin control */</span></span><br><span class="line">    <span class="comment">/** 获取服务器CPU核数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Maximum number of retries before enqueuing on acquisition */</span></span><br><span class="line">    <span class="comment">/** 线程入队列前自旋次数 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">6</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Maximum number of retries before blocking at head on acquisition */</span></span><br><span class="line">    <span class="comment">/** 队列头结点自旋获取锁最大失败次数后再次进入队列 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">10</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Maximum number of retries before re-blocking */</span></span><br><span class="line">    <span class="comment">//重新阻止之前的最大重试次数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HEAD_SPINS = (NCPU &gt; <span class="number">1</span>) ? <span class="number">1</span> &lt;&lt; <span class="number">16</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The period for yielding when waiting for overflow spinlock */</span></span><br><span class="line">    <span class="comment">//等待溢出螺旋锁时产生屈服期</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OVERFLOW_YIELD_RATE = <span class="number">7</span>; <span class="comment">// must be power 2 - 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The number of bits to use for reader count before overflowing */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> LG_READERS = <span class="number">7</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   有没有写线程获取到了写状态只需判断：state &lt; WBIT</span></span><br><span class="line"><span class="comment">         读状态是否超出：(state &amp; ABITS) &lt; RFULL</span></span><br><span class="line"><span class="comment">         获取读状态：  state + RUNIT(或者readerOverflow + 1)</span></span><br><span class="line"><span class="comment">         获取写状态:      state + WBIT</span></span><br><span class="line"><span class="comment">         释放读状态：  state - RUNIT(或者readerOverflow - 1)</span></span><br><span class="line"><span class="comment">         释放写状态：  (s += WBIT) == 0L ? ORIGIN : s</span></span><br><span class="line"><span class="comment">         是否为写锁：  (state &amp; WBIT) != 0L</span></span><br><span class="line"><span class="comment">         是否为读锁：  (state &amp; RBITS) != 0L</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values for lock state and stamp operations</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RUNIT = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WBIT  = <span class="number">1L</span> &lt;&lt; LG_READERS; <span class="comment">//0000 0000 0000 0000  0000 0000 0000  0000 0000 0000 0000  0000 0000 1000 0000</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RBITS = WBIT - <span class="number">1L</span>;        <span class="comment">//0000 0000 0000 0000  0000 0000 0000  0000 0000 0000 0000  0000 0000 0111 1111</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> RFULL = RBITS - <span class="number">1L</span>;       <span class="comment">//0000 0000 0000 0000  0000 0000 0000  0000 0000 0000 0000  0000 0000 0111 1110</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ABITS = RBITS | WBIT;     <span class="comment">//0000 0000 0000 0000  0000 0000 0000  0000 0000 0000 0000  0000 0000 1111 1111</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SBITS = ~RBITS;           <span class="comment">//1111 1111 1111 1111  1111 1111 1111  1111 1111 1111 1111  1111 1111 1000 0000  note overlap with ABITS</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initial value for lock state; avoid failure value zero</span></span><br><span class="line">    <span class="comment">//锁state初始值，第9位为1，避免算术时和0冲突</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ORIGIN = WBIT &lt;&lt; <span class="number">1</span>;   <span class="comment">//0000 0000 0000 0000  0000 0000 0000  0000 0000 0000 0000  0000 0001 0000 0000</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Special value from cancelled acquire methods so caller can throw IE</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> INTERRUPTED = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values for node status; order matters</span></span><br><span class="line">    <span class="comment">// WNode节点的status值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITING   = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Modes for nodes (int not boolean to allow arithmetic)</span></span><br><span class="line">    <span class="comment">// WNode节点的读写模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RMODE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WMODE = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Head of CLH queue */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode whead;</span><br><span class="line">    <span class="comment">/** Tail (last) of CLH queue */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> WNode wtail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// views</span></span><br><span class="line">    <span class="keyword">transient</span> ReadLockView readLockView;</span><br><span class="line">    <span class="keyword">transient</span> WriteLockView writeLockView;</span><br><span class="line">    <span class="keyword">transient</span> ReadWriteLockView readWriteLockView;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Lock sequence/state */</span></span><br><span class="line">    <span class="comment">/** 锁队列状态， 当处于写模式时第8位为1，读模式时前7位为1-126（附加的readerOverflow用于当读者超过126时） */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** extra reader count when state read count saturated */</span></span><br><span class="line">    <span class="comment">/** 将state超过 RFULL=126的值放到readerOverflow字段中 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> readerOverflow;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> WNode prev;</span><br><span class="line">        <span class="keyword">volatile</span> WNode next;</span><br><span class="line">        <span class="keyword">volatile</span> WNode cowait;    <span class="comment">// list of linked readers （读模式使用该节点形成栈。用于链接等待获取读状态的节点。）</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;   <span class="comment">// non-null while possibly parked</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> status;      <span class="comment">// 0, WAITING, or CANCELLED</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode;           <span class="comment">// RMODE or WMODE</span></span><br><span class="line">        WNode(<span class="keyword">int</span> m, WNode p) &#123; mode = m; prev = p; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLockView</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLockView</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockView</span> <span class="keyword">implements</span> <span class="title">ReadWriteLock</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由源码可知，StampedLock锁与其他的锁不一样。其他的锁，如：ReentrantLock，都是基于AQS实现的，StampedLock锁并没有实现AQS抽象类。StampedLock锁与AQS一样，内部也有一个<code>state</code>字段，用来表示锁状态，但是声明为<code>long</code>型，而非AQS中的<code>int</code>型。<font color="red">在StampedLock锁中，当处于写模式时stats二进制的第8位为1，读模式时前7位为1-126（附加的readerOverflow用于当读者超过126时）。</font></p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StampedLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    state = ORIGIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造StampedLock对象时，会初始化<code>state</code>的值为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^8</span><br></pre></td></tr></table></figure></p>
<p>即二进制：<br>0000 0000 0000 0000  0000 0000 0000  0000 0000 0000 0000  0000 0001 0000 0000</p>
<h5 id="读锁获取"><a href="#读锁获取" class="headerlink" title="读锁获取"></a>读锁获取</h5><h6 id="readLock源码"><a href="#readLock源码" class="headerlink" title="readLock源码"></a>readLock源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//悲观读锁，非独占锁，为获得锁一直处于阻塞状态，直到获得锁为止</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">readLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s = state, next;  <span class="comment">// bypass acquireRead on common uncontended case</span></span><br><span class="line">    <span class="comment">// 队列为空   &amp;&amp; 没有写锁同时读锁数小于126  &amp;&amp; CAS修改状态成功      则状态加1并返回，否则自旋获取读锁</span></span><br><span class="line">    <span class="keyword">return</span> ((whead == wtail &amp;&amp; (s &amp; ABITS) &lt; RFULL &amp;&amp;</span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT)) ?</span><br><span class="line">            next : acquireRead(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法实现了悲观锁的获取。在<code>排队等待队列为空</code> 且<code>没有写锁同时读锁数小于126</code> 且 <code>CAS修改状态成功</code>，则状态加1并返回，否则自旋获取读锁。</p>
<h6 id="acquireRead源码"><a href="#acquireRead源码" class="headerlink" title="acquireRead源码"></a>acquireRead源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">acquireRead</span><span class="params">(<span class="keyword">boolean</span> interruptible, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    WNode node = <span class="keyword">null</span>, p;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">        WNode h;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *   if块功能：</span></span><br><span class="line"><span class="comment">         *   先判断同步队列是否为空，如果为空那么尝试获取读状态，同时如果此时写状态被占有的话还是会根据spins的值随机的自旋一定的时间如果还是没获取到则跳出自旋进入外层的循环。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((h = whead) == (p = wtail)) &#123;   <span class="comment">//判断队列为空</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> m, s, ns;;) &#123;</span><br><span class="line">                <span class="comment">//将state超过 RFULL=126的值放到readerOverflow字段中。m &lt; WBIT说明没有写状态被占有</span></span><br><span class="line">                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                    U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + RUNIT) :</span><br><span class="line">                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))</span><br><span class="line">                    <span class="keyword">return</span> ns;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT) &#123; <span class="comment">//state高8位大于0，那么说明当前锁已经被写锁独占，那么我们尝试自旋  + 随机的方式来探测状态</span></span><br><span class="line">                    <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>)</span><br><span class="line">                            --spins;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (spins == <span class="number">0</span>) &#123;</span><br><span class="line">                            WNode nh = whead, np = wtail;</span><br><span class="line">                            <span class="comment">//一直获取锁失败，或者有线程入队列了退出内循环自旋，后续进入队列。</span></span><br><span class="line">                            <span class="comment">// 判断稳定性（有没有被修改）</span></span><br><span class="line">                            <span class="keyword">if</span> ((nh == h &amp;&amp; np == p) || (h = nh) != (p = np))</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//自旋 SPINS 次</span></span><br><span class="line">                        spins = SPINS;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果同步队列不为空，说明已经有别的线程在排队了（写线程），那么开始检查是否需要初始化，如果没有初始化则构造一个WMODE的节点作为头节点。由上个if语句可知，只有当前锁被写锁独占，才能跳出上个if语句中的for循环执行到此处。</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123; <span class="comment">// initialize queue //初始队列</span></span><br><span class="line">            <span class="comment">//由于此时是有写线程占有同步状态所以用一个WMODE的节点放入队列</span></span><br><span class="line">            WNode hd = <span class="keyword">new</span> WNode(WMODE, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//CAS插入，如果失败的话下次循环再次尝试</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WHEAD, <span class="keyword">null</span>, hd))</span><br><span class="line">                wtail = hd;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *   if语句功能分析：</span></span><br><span class="line"><span class="comment">         *   此时构造当前线程的节点node尝试加入同步队列，加入的方式有两种，</span></span><br><span class="line"><span class="comment">         *      1：是如果队列的tail是WMODE或者队列的head==tail，那么直接加入队列的尾部，并跳出外层循环；</span></span><br><span class="line"><span class="comment">         *      2：是加入tail节点的cowait的链中。并继续执行。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//当前节点为空则构建当前节点，模式为RMODE，前驱节点为p即尾节点。（初始化代表当前读线程的节点）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">            node = <span class="keyword">new</span> WNode(RMODE, p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将当前线程node节点加入同步队列方式1，添加到队列尾部</span></span><br><span class="line">            <span class="comment">//当前队列为空即只有一个节点（whead=wtail）或者当前尾节点的模式不是RMODE，那么我们会尝试在尾节点后面添加该节点作为尾节点，然后跳出外层循环</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h == p || p.mode != RMODE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.prev != p)</span><br><span class="line">                node.prev = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WTAIL, p, node)) &#123;</span><br><span class="line">                p.next = node;</span><br><span class="line">                <span class="keyword">break</span>;   <span class="comment">//入队列成功，退出自旋。执行第二个for循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将当前线程node节点加入同步队列方式2，添加到队列尾部节点中的cowait队列中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!U.compareAndSwapObject(p, WCOWAIT,</span><br><span class="line">                                         node.cowait = p.cowait, node))   <span class="comment">//队列不为空并且是RMODE模式， 添加该节点到尾节点的cowait链（实际上构成一个读线程stack）中</span></span><br><span class="line">            node.cowait = <span class="keyword">null</span>; <span class="comment">//失败处理</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果上面加入tail节点的cowait链中的CAS操作成功，则释放cowait链中的节点。</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过CAS方法将该节点node添加至尾节点的cowait链中，node成为cowait中的顶元素，cowait构成了一个LIFO队列。</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                WNode pp, c; Thread w;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果head不为空那么尝试去解放head的cowait链中的节点</span></span><br><span class="line">                <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; (c = h.cowait) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (w = c.thread) != <span class="keyword">null</span>) <span class="comment">// help release</span></span><br><span class="line">                    U.unpark(w);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="comment">//node所在的根节点p的前驱就是whead或者p已经是whead或者p的前驱为null</span></span><br><span class="line">                <span class="keyword">if</span> (h == (pp = p.prev) || h == p || pp == <span class="keyword">null</span>) &#123;  <span class="comment">//因为是成功执行U.compareAndSwapObject()操作后，程序才能走到此处，因此可知，p依然为队列中的尾节点。</span></span><br><span class="line">                    <span class="keyword">long</span> m, s, ns;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        <span class="comment">//根据state再次积极的尝试获取锁</span></span><br><span class="line">                        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                            U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                                 ns = s + RUNIT) :</span><br><span class="line">                            (m &lt; WBIT &amp;&amp;</span><br><span class="line">                             (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>))</span><br><span class="line">                            <span class="keyword">return</span> ns;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (m &lt; WBIT); <span class="comment">//条件为读模式</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//判断是否稳定</span></span><br><span class="line">                <span class="keyword">if</span> (whead == h &amp;&amp; p.prev == pp) &#123;</span><br><span class="line">                    <span class="keyword">long</span> time;</span><br><span class="line">                    <span class="comment">//如果tail的前驱是null或者head==tail或者tail已经被取消了(p.status &gt; 0)</span></span><br><span class="line">                    <span class="comment">//直接将node置为null跳出循环，回到最开的for循环中去再次尝试获取同步状态</span></span><br><span class="line">                    <span class="keyword">if</span> (pp == <span class="keyword">null</span> || h == p || p.status &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//这样做的原因是被其他线程闯入夺取了锁，或者p已经被取消</span></span><br><span class="line">                        node = <span class="keyword">null</span>; <span class="comment">// throw away</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//判断超时</span></span><br><span class="line">                    <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                        time = <span class="number">0L</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)    <span class="comment">//如果超时则取消当前线程</span></span><br><span class="line">                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="keyword">false</span>);</span><br><span class="line">                    Thread wt = Thread.currentThread();</span><br><span class="line">                    U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                    node.thread = wt;</span><br><span class="line">                    <span class="comment">//tail的前驱不是head或者当前只有写线程获取到同步状态</span></span><br><span class="line">                    <span class="keyword">if</span> ((h != pp || (state &amp; ABITS) == WBIT) &amp;&amp;</span><br><span class="line">                        whead == h &amp;&amp; p.prev == pp)</span><br><span class="line">                        U.park(<span class="keyword">false</span>, time);</span><br><span class="line">                    node.thread = <span class="keyword">null</span>;</span><br><span class="line">                    U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//中断的话取消</span></span><br><span class="line">                    <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                        <span class="keyword">return</span> cancelWaiter(node, p, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在该for循环中，节点的自旋限制为先驱节点就是头节点，并且自旋同样不是无休止的，而是通过一个spins的值来控制，并且是相对随机的。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//如果tail的mode是WMODE写状态，那么node被加入到队列的tail之后进入这个循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">        WNode h, np, pp; <span class="keyword">int</span> ps;</span><br><span class="line">        <span class="comment">//如果p(node的前驱节点)就是head，那么自旋方式尝试获取同步状态</span></span><br><span class="line">        <span class="keyword">if</span> ((h = whead) == p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                spins = HEAD_SPINS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)</span><br><span class="line">                spins &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = spins;;) &#123; <span class="comment">// spin at head</span></span><br><span class="line">                <span class="keyword">long</span> m, s, ns;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//自旋方式尝试获取同步状态</span></span><br><span class="line">                <span class="comment">//获取成功的话将node设置为head并解放node的cowait链中的节点并返回stamp</span></span><br><span class="line">                <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) &lt; RFULL ?</span><br><span class="line">                    U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + RUNIT) :</span><br><span class="line">                    (m &lt; WBIT &amp;&amp; (ns = tryIncReaderOverflow(s)) != <span class="number">0L</span>)) &#123;</span><br><span class="line">                    WNode c; Thread w;</span><br><span class="line">                    whead = node;</span><br><span class="line">                    node.prev = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">while</span> ((c = node.cowait) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(node, WCOWAIT,</span><br><span class="line">                                                   c, c.cowait) &amp;&amp;</span><br><span class="line">                            (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                            U.unpark(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> ns;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果有写线程获取到了同步状态(因为可能有写线程闯入)那么随机的--k控制循环次数</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (m &gt;= WBIT &amp;&amp;</span><br><span class="line">                         LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp; --k &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果head不为null，解放head的cowait链中的节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WNode c; Thread w;</span><br><span class="line">            <span class="keyword">while</span> ((c = h.cowait) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断稳定性</span></span><br><span class="line">        <span class="keyword">if</span> (whead == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((np = node.prev) != p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (np != <span class="keyword">null</span>)</span><br><span class="line">                    (p = np).next = node;   <span class="comment">// stale</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//尝试设tail的状态位WAITING表示后面还有等待的节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)</span><br><span class="line">                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;   <span class="comment">//如果tail已经取消了，跳过tail</span></span><br><span class="line">                <span class="keyword">if</span> ((pp = p.prev) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.prev = pp;</span><br><span class="line">                    pp.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> time;</span><br><span class="line">                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                    time = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">false</span>);</span><br><span class="line">                Thread wt = Thread.currentThread();</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                node.thread = wt;</span><br><span class="line">                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    (p != h || (state &amp; ABITS) == WBIT) &amp;&amp;</span><br><span class="line">                    whead == h &amp;&amp; node.prev == p)</span><br><span class="line">                    U.park(<span class="keyword">false</span>, time);</span><br><span class="line">                node.thread = <span class="keyword">null</span>;</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在调用readLock方法时，会首先尝试直接CAS改变state（<code>在whead==wtail和(s &amp; ABITS) &lt; RFULL的情况下</code>），成功的话直接返回stamp（next）。<br>竞争失败的情况下进入acquireRead的逻辑。acquireRead内部有两个代码比较多的for循环：</p>
<ol>
<li><p>第一个for循环</p>
<p> 功能：首先在队列为空且没有写锁的情况下，尝试循环获取读锁，直至有写锁时，把当前线程入队，并使当前线程睡眠。</p>
</li>
<li><p>第二个for循环</p>
<p> 功能：在第一个for循环中，把当前线程入队时，有两种情况：（1）队列不为空且尾节点为RMODE模式，则把当前线程添加到尾节点的cowait链中（实际上构成一个读线程stack）；（2）情况1不满足的情况下，则把当前线程作为尾节点。在情况2发生时，则会跳出第一个for循环，进入第二个for循环。该循环的功能主要是在当前线程组成的node的前驱节点位head时，继续尝试获取锁；在head不为null时，释放cowait链中的节点；在可能的情况下，使当前线程睡眠。</p>
</li>
</ol>
<p>下面详细描述acquireRead的内部逻辑：</p>
<ul>
<li>acquireRead方法调用，然后进入第一个for循环。</li>
<li>首先取得whead和wtail两个值，假如这两个值不等说明等待队列不为空，那么获取读锁没希望了，会进入等待队列。</li>
<li>如果<code>whead == wtail</code> ，会进入内部的for循环，在读锁未超过RFULL=126时，尽力尝试通过前7bit上递增state来获取锁；如果超过了，并且在没有写锁的情况下(m &lt; WBIT)，超出126的部分最终到了readerOverflow中，加入获取了锁就返回stamp。假如m &gt;= WBIT，也就是说m（state前8位）值大于或等于128，那么说明当前锁已经被写者独占，那么我们尝试自旋+随机的方式来探测状态，并且在当前队列和进入循环前一样（说明还没有其他入队者）或者当前队列中已经有了入队者的情况下内层循环跳出，接着肯定会入队。</li>
<li>首先根据尾节点为null的情况探测是否初始化队列，使用一个WMODE模式的节点初始化whead和wtail。（因为只有当前锁被写锁独占，才能跳出上个if语句中的for循环，所以会创建一个WMODE模式的节点初始化队列）</li>
<li>然后假如当前节点为空则构建当前节点，模式为RMODE，前驱节点为p即尾节点。</li>
<li>接着假如当前队列为空即只有一个节点（whead=wtail）或者当前尾节点的模式不是RMODE，那么我们会尝试在尾节点后面添加该节点作为尾节点，然后跳出外层循环；假如当前队列不为空并且当前尾节点模式就是RMODE，那么我们会尝试下一步：添加该节点到尾节点的cowait链（实际上构成一个stack）中。</li>
</ul>
<p>当前尾节点模式为RMODE模式时逻辑：</p>
<ul>
<li>通过CAS方法将该节点node添加至尾节点的cowait链中，node成为cowait中的顶元素，cowait构成了一个LIFO队列。</li>
<li>成功后进入另一个循环，首先尝试unpark头元素（whead）的cowait中的第一个元素，这只是一种辅助作用，因为头元素whead所伴随的那个线程（假如存在）必定是已经获得锁了，假如是读锁那么也必定会释放cowait链。</li>
<li>假如当前节点node所在的根节点p的前驱就是whead或者p已经是whead或者p的前驱为null，那么我们会根据state再次积极的尝试获取锁（当m &lt; WBIT）。</li>
<li>否则我们探测当前队列是否稳定：<code>whead == h &amp;&amp; p.prev == pp</code>，在稳定的情况下，假如发现p成为过head或者p已经被取消（status&gt;0），我们尝试node=null，并且跳出当前循环，回到一开的循环里面去尝试获取锁（这样做的原因是被其他线程闯入夺取了锁，或者p已经被取消）。</li>
<li>接着我们判断是否为限时版本，以及限时版本所需时间。</li>
<li>然后park当前线程以及可能出现的中断情况下取消当前节点的cancelWaiter操作。</li>
</ul>
<p>我们再来分析跳出循环的另一种情况：队列中无节点或者尾节点模式为WMODE：这样我们的节点必须直接拼接到尾节点后面。下面为第二个for循环逻辑：</p>
<ul>
<li>p作为当前节点的前驱节点，假如正好是whead的话，那么会尝试自旋+随机的方式在积极得探测state，从而能够取得锁。并且在获得锁，重置whead和node.prev=null之后释放当前cowait链中的节点。最后返回stamp。</li>
<li>否则只需h不为null时尝试释放当前头节点的cowait链，作为一种协作的积极行动。</li>
<li>然后在whead==h即队列稳定时，首先会CAS操作当前节点前驱的status，从0变为WAITING从而指示后面有等待的节点。假如发现p的状态已经为取消了，则重新选择node的前驱。</li>
<li>前面的这些都处理完成之后，使用类似的park以及cancelWaiter操作。区别在于这里的p.status&lt;0必须保证（因为等待状态WAITING是-1）。</li>
</ul>
<h6 id="tryIncReaderOverflow源码"><a href="#tryIncReaderOverflow源码" class="headerlink" title="tryIncReaderOverflow源码"></a>tryIncReaderOverflow源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tryIncReaderOverflow</span><span class="params">(<span class="keyword">long</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert (s &amp; ABITS) &gt;= RFULL;</span></span><br><span class="line">    <span class="keyword">if</span> ((s &amp; ABITS) == RFULL) &#123;</span><br><span class="line">        <span class="comment">//将state超过 RFULL=126的值放到readerOverflow字段中，state保持不变，但锁状态+1</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s | RBITS)) &#123;</span><br><span class="line">            ++readerOverflow;</span><br><span class="line">            state = s;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((LockSupport.nextSecondarySeed() &amp;     <span class="comment">//LockSupport.nextSecondarySeed() 生成随机数</span></span><br><span class="line">              OVERFLOW_YIELD_RATE) == <span class="number">0</span>)</span><br><span class="line">        Thread.yield(); <span class="comment">//线程放弃CPU资源</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将state超过 RFULL=126的值放到readerOverflow字段中，state的前七位记录到126之后就会稳定在这个值，偶尔会到127，但是超出126的部分最终到了readerOverflow，加入获取了锁就返回stamp。</p>
<h6 id="cancelWaiter源码"><a href="#cancelWaiter源码" class="headerlink" title="cancelWaiter源码"></a>cancelWaiter源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node if nonnull, the waiter</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> group either node or the group node is cowaiting with</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> interrupted if already interrupted</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> INTERRUPTED if interrupted or Thread.interrupted, else zero</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">cancelWaiter</span><span class="params">(WNode node, WNode group, <span class="keyword">boolean</span> interrupted)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; group != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Thread w;</span><br><span class="line">        node.status = CANCELLED;</span><br><span class="line">        <span class="comment">// unsplice cancelled nodes from group</span></span><br><span class="line">        <span class="comment">// 移除栈中取消状态的节点</span></span><br><span class="line">        <span class="keyword">for</span> (WNode p = group, q; (q = p.cowait) != <span class="keyword">null</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.status == CANCELLED) &#123;</span><br><span class="line">                U.compareAndSwapObject(p, WCOWAIT, q, q.cowait);</span><br><span class="line">                p = group; <span class="comment">// restart</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (group == node) &#123;</span><br><span class="line">            <span class="comment">//唤醒栈中所有非取消状态节点线程</span></span><br><span class="line">            <span class="keyword">for</span> (WNode r = group.cowait; r != <span class="keyword">null</span>; r = r.cowait) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((w = r.thread) != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);       <span class="comment">// wake up uncancelled co-waiters</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (WNode pred = node.prev; pred != <span class="keyword">null</span>; ) &#123; <span class="comment">// unsplice</span></span><br><span class="line">                <span class="comment">// 寻找到node后面的第一个非CANCELLED节点，直接拼接到pred上</span></span><br><span class="line">                WNode succ, pp;        <span class="comment">// find valid successor</span></span><br><span class="line">                <span class="keyword">while</span> ((succ = node.next) == <span class="keyword">null</span> ||</span><br><span class="line">                       succ.status == CANCELLED) &#123;</span><br><span class="line">                    WNode q = <span class="keyword">null</span>;    <span class="comment">// find successor the slow way</span></span><br><span class="line">                    <span class="keyword">for</span> (WNode t = wtail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                        <span class="keyword">if</span> (t.status != CANCELLED)</span><br><span class="line">                            q = t;     <span class="comment">// don't link if succ cancelled</span></span><br><span class="line">                    <span class="keyword">if</span> (succ == q ||   <span class="comment">// ensure accurate successor</span></span><br><span class="line">                        U.compareAndSwapObject(node, WNEXT,</span><br><span class="line">                                               succ, succ = q)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (succ == <span class="keyword">null</span> &amp;&amp; node == wtail)</span><br><span class="line">                            U.compareAndSwapObject(<span class="keyword">this</span>, WTAIL, node, pred);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将当前节点的前置节点链接到当前节点的后继节点</span></span><br><span class="line">                <span class="keyword">if</span> (pred.next == node) <span class="comment">// unsplice pred link</span></span><br><span class="line">                    U.compareAndSwapObject(pred, WNEXT, node, succ);</span><br><span class="line">                <span class="keyword">if</span> (succ != <span class="keyword">null</span> &amp;&amp; (w = succ.thread) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    succ.thread = <span class="keyword">null</span>;</span><br><span class="line">                    U.unpark(w);       <span class="comment">// wake up succ to observe new pred</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//检查前驱节点状态，假如为CANCELLED则也需要重置前驱节点。</span></span><br><span class="line">                <span class="keyword">if</span> (pred.status != CANCELLED || (pp = pred.prev) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                node.prev = pp;        <span class="comment">// repeat if new pred wrong/cancelled</span></span><br><span class="line">                U.compareAndSwapObject(pp, WNEXT, pred, succ);</span><br><span class="line">                pred = pp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    WNode h; <span class="comment">// Possibly release first waiter</span></span><br><span class="line">    <span class="keyword">while</span> ((h = whead) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> s; WNode q; <span class="comment">// similar to release() but check eligibility</span></span><br><span class="line">        <span class="keyword">if</span> ((q = h.next) == <span class="keyword">null</span> || q.status == CANCELLED) &#123;</span><br><span class="line">            <span class="keyword">for</span> (WNode t = wtail; t != <span class="keyword">null</span> &amp;&amp; t != h; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.status &lt;= <span class="number">0</span>)</span><br><span class="line">                    q = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == whead) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; h.status == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                ((s = state) &amp; ABITS) != WBIT &amp;&amp; <span class="comment">// waiter is eligible</span></span><br><span class="line">                (s == <span class="number">0L</span> || q.mode == RMODE))</span><br><span class="line">                release(h);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (interrupted || Thread.interrupted()) ? INTERRUPTED : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的功能就是在等待队列中取消当前节点。内部逻辑为：</p>
<ul>
<li>首先设置node的状态为CANCELLED，可以向其他线程传递这个节点是删除了的信息。</li>
<li>然后再聚合节点gruop上清理所有状态为CANCELLED的节点（即删除节点）</li>
<li>接下来假如当期node节点本身就是聚合节点，那么首先唤醒cowait链中的所有节点（读者），寻找到node后面的第一个非CANCELLED节点，直接拼接到pred上（从而删除当前节点），然后再检查前驱节点状态，假如为CANCELLED则也需要重置前驱节点。</li>
<li>最后，在队列中不为空，并且头结点的状态为0即队列中的节点还未设置WAITING信号&amp;当前没有持有写入锁模式&amp;（当前没有锁或者只有乐观锁 | 队列中第一个等待者为读模式），那么就从队列头唤醒一次。</li>
</ul>
<h6 id="release源码"><a href="#release源码" class="headerlink" title="release源码"></a>release源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放当前节点， 唤醒继任者节点线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(WNode h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WNode q; Thread w;</span><br><span class="line">        U.compareAndSwapInt(h, WSTATUS, WAITING, <span class="number">0</span>);    <span class="comment">//将状态由WAITING改为0</span></span><br><span class="line">        <span class="keyword">if</span> ((q = h.next) == <span class="keyword">null</span> || q.status == CANCELLED) &#123;    <span class="comment">//找到下个status为WAITING的节点，并唤醒线程。如果当期节点的后继节点为null，或者状态为CANCELLED时，从wtail往前遍历，找到status为WAITING的节点</span></span><br><span class="line">            <span class="keyword">for</span> (WNode t = wtail; t != <span class="keyword">null</span> &amp;&amp; t != h; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.status &lt;= <span class="number">0</span>)</span><br><span class="line">                    q = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; (w = q.thread) != <span class="keyword">null</span>)</span><br><span class="line">            U.unpark(w);    <span class="comment">//唤醒线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="读锁释放"><a href="#读锁释放" class="headerlink" title="读锁释放"></a>读锁释放</h5><h6 id="unlockRead源码"><a href="#unlockRead源码" class="headerlink" title="unlockRead源码"></a>unlockRead源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockRead</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, m; WNode h;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (((s = state) &amp; SBITS) != (stamp &amp; SBITS) ||</span><br><span class="line">            (stamp &amp; ABITS) == <span class="number">0L</span> || (m = s &amp; ABITS) == <span class="number">0L</span> || m == WBIT)    <span class="comment">//不匹配抛出异常。state &amp; SBITS 之后将抹去前7位以外的部分只剩下读状态</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; RFULL) &#123;    <span class="comment">//小于最大记录数值</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                    release(h);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>) <span class="comment">//否则readerOverflow减一</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在释放锁时，会传递一个stamp值，进行锁验证，如果验证通过，则直接修改<code>state</code>中代表读状态的值。在读状态数小于最大记录数时，直接修改<code>state</code>的值，并唤醒头结点中的线程；在大于时，修改<code>readerOverflow</code>值。</p>
<h6 id="tryDecReaderOverflow源码"><a href="#tryDecReaderOverflow源码" class="headerlink" title="tryDecReaderOverflow源码"></a>tryDecReaderOverflow源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">tryDecReaderOverflow</span><span class="params">(<span class="keyword">long</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert (s &amp; ABITS) &gt;= RFULL;</span></span><br><span class="line">    <span class="keyword">if</span> ((s &amp; ABITS) == RFULL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s | RBITS)) &#123;</span><br><span class="line">            <span class="keyword">int</span> r; <span class="keyword">long</span> next;</span><br><span class="line">            <span class="keyword">if</span> ((r = readerOverflow) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                readerOverflow = r - <span class="number">1</span>;</span><br><span class="line">                next = s;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next = s - RUNIT;</span><br><span class="line">             state = next;</span><br><span class="line">             <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((LockSupport.nextSecondarySeed() &amp;</span><br><span class="line">              OVERFLOW_YIELD_RATE) == <span class="number">0</span>)</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="写锁获取"><a href="#写锁获取" class="headerlink" title="写锁获取"></a>写锁获取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取写锁，获取失败会一直阻塞，直到获得锁成功</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">writeLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s, next;  <span class="comment">// bypass acquireWrite in fully unlocked case only</span></span><br><span class="line">    <span class="keyword">return</span> ((((s = state) &amp; ABITS) == <span class="number">0L</span> &amp;&amp;         <span class="comment">//完全没有任何锁（没有读锁和写锁）的时候可以通过，即判断state是否为初始态</span></span><br><span class="line">             U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT)) ?   <span class="comment">////第8位置为1,next = s + WBIT = 1 0000 0000 + 1000 0000 = 1 1000 0000</span></span><br><span class="line">            next : acquireWrite(<span class="keyword">false</span>, <span class="number">0L</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取写锁时，如果在完全没有锁的情况下（既没有读锁，也没有写锁），会直接尝试CAS获取写锁。获取成功，直接返回；获取失败，则会调用acquireWrite方法。</p>
<h6 id="acquireWrite源码"><a href="#acquireWrite源码" class="headerlink" title="acquireWrite源码"></a>acquireWrite源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">acquireWrite</span><span class="params">(<span class="keyword">boolean</span> interruptible, <span class="keyword">long</span> deadline)</span> </span>&#123;</span><br><span class="line">    WNode node = <span class="keyword">null</span>, p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写状态的获取基本和读一样，区别在于写状态获取的时候根本就没有去判断同步队列里面是否有节点，</span></span><br><span class="line"><span class="comment">     * 而且尝试获取写状态的条件是(s = state) &amp; ABITS) == 0L，也就是说要没有任何的其他锁占用的情况下才会去CAS尝试获取写状态。</span></span><br><span class="line"><span class="comment">     * 同时如果获取失败加入同步队列的时候只会直接加入同步队列的尾部，不会加入cowait链。这也说明了StampedLock的写是无条件去获取锁。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123; <span class="comment">// spin while enqueuing（轮询入队）</span></span><br><span class="line">        <span class="keyword">long</span> m, s, ns;</span><br><span class="line">        <span class="keyword">if</span> ((m = (s = state) &amp; ABITS) == <span class="number">0L</span>) &#123; <span class="comment">//无锁</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, ns = s + WBIT))</span><br><span class="line">                <span class="keyword">return</span> ns;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; <span class="number">0</span>) <span class="comment">//持有写锁，并且队列为空</span></span><br><span class="line">            spins = (m == WBIT &amp;&amp; wtail == whead) ? SPINS : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span>) <span class="comment">//恒成立</span></span><br><span class="line">                --spins;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((p = wtail) == <span class="keyword">null</span>) &#123; <span class="comment">// initialize queue</span></span><br><span class="line">            WNode hd = <span class="keyword">new</span> WNode(WMODE, <span class="keyword">null</span>);  <span class="comment">//初始化队列，写锁入队列</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WHEAD, <span class="keyword">null</span>, hd))</span><br><span class="line">                wtail = hd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="comment">//p不为空，即队列不为空，写锁入队列</span></span><br><span class="line">            node = <span class="keyword">new</span> WNode(WMODE, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (node.prev != p)</span><br><span class="line">            node.prev = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, WTAIL, p, node)) &#123;</span><br><span class="line">            p.next = node;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//入队列成功退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> spins = -<span class="number">1</span>;;) &#123;</span><br><span class="line">        WNode h, np, pp; <span class="keyword">int</span> ps;</span><br><span class="line">        <span class="keyword">if</span> ((h = whead) == p) &#123; <span class="comment">//前驱节点为头节点</span></span><br><span class="line">            <span class="keyword">if</span> (spins &lt; <span class="number">0</span>)</span><br><span class="line">                spins = HEAD_SPINS;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (spins &lt; MAX_HEAD_SPINS)</span><br><span class="line">                spins &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = spins;;) &#123; <span class="comment">// spin at head</span></span><br><span class="line">                <span class="keyword">long</span> s, ns;</span><br><span class="line">                <span class="keyword">if</span> (((s = state) &amp; ABITS) == <span class="number">0L</span>) &#123;  <span class="comment">//无锁</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                             ns = s + WBIT)) &#123;</span><br><span class="line">                        whead = node;  <span class="comment">//当前节点设置为头结点</span></span><br><span class="line">                        node.prev = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">return</span> ns;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (LockSupport.nextSecondarySeed() &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         --k &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (h != <span class="keyword">null</span>) &#123; <span class="comment">// help release stale waiters</span></span><br><span class="line">            WNode c; Thread w;</span><br><span class="line">            <span class="keyword">while</span> ((c = h.cowait) != <span class="keyword">null</span>) &#123;    <span class="comment">//头结点为读锁将栈中所有读锁线程唤醒</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(h, WCOWAIT, c, c.cowait) &amp;&amp;</span><br><span class="line">                    (w = c.thread) != <span class="keyword">null</span>)</span><br><span class="line">                    U.unpark(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (whead == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((np = node.prev) != p) &#123;</span><br><span class="line">                <span class="keyword">if</span> (np != <span class="keyword">null</span>)</span><br><span class="line">                    (p = np).next = node;   <span class="comment">// stale</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ps = p.status) == <span class="number">0</span>)</span><br><span class="line">                U.compareAndSwapInt(p, WSTATUS, <span class="number">0</span>, WAITING);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ps == CANCELLED) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((pp = p.prev) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    node.prev = pp;</span><br><span class="line">                    pp.next = node;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> time; <span class="comment">// 0 argument to park means no timeout</span></span><br><span class="line">                <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                    time = <span class="number">0L</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((time = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">false</span>);</span><br><span class="line">                Thread wt = Thread.currentThread();</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">this</span>);</span><br><span class="line">                node.thread = wt;</span><br><span class="line">                <span class="keyword">if</span> (p.status &lt; <span class="number">0</span> &amp;&amp; (p != h || (state &amp; ABITS) != <span class="number">0L</span>) &amp;&amp;</span><br><span class="line">                    whead == h &amp;&amp; node.prev == p)</span><br><span class="line">                    U.park(<span class="keyword">false</span>, time);  <span class="comment">// emulate LockSupport.park</span></span><br><span class="line">                node.thread = <span class="keyword">null</span>;</span><br><span class="line">                U.putObject(wt, PARKBLOCKER, <span class="keyword">null</span>);</span><br><span class="line">                <span class="keyword">if</span> (interruptible &amp;&amp; Thread.interrupted())</span><br><span class="line">                    <span class="keyword">return</span> cancelWaiter(node, node, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>acquireWrite方法逻辑实现中，也有两个for循环：</p>
<ol>
<li><p>第一个for循环</p>
<p> 功能：在无任何锁的情况下，会直接通过CAS操作获取写锁；否则，在持有写锁，并且队列为空的情况下，自旋一段时间获取写锁后，如果还未成功获取到写锁，则将当前线程入队列（在入队列之前，若队列为空，先初始化队列），入队成功后，跳出第一个循环。</p>
</li>
<li><p>第二个for循环 （与acquireRead方法的第二个for循环逻辑差不多）</p>
<ul>
<li>在当前线程入队成功后，如果其前驱结点为头结点，且无任何锁的情况下，则根据头结点自旋次数，循环获取写锁；自旋次数完后，若还未获取锁，则跳出内部循环。</li>
<li>如头结点不为空，则释放头结点中cowait链上的节点</li>
<li>然后若在whead==h即队列稳定时，首先会CAS操作当前节点前驱的status，从0变为WAITING从而指示后面有等待的节点。假如发现p的状态已经为取消了，则重新选择node的前驱。<ul>
<li>前面的这些都处理完成之后，使用类似的park以及cancelWaiter操作。区别在于这里的p.status&lt;0必须保证（因为等待状态WAITING是-1）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h6 id="释放写锁"><a href="#释放写锁" class="headerlink" title="释放写锁"></a>释放写锁</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlockWrite</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    WNode h;</span><br><span class="line">    <span class="comment">//因为写锁是独占式的所以可以简单判断state != stamp</span></span><br><span class="line">    <span class="keyword">if</span> (state != stamp || (stamp &amp; WBIT) == <span class="number">0L</span>) <span class="comment">//state不匹配stamp  或者 没有写锁</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//state += WBIT， 第8位置为0</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *这里的(stamp += WBIT) == 0L ? ORIGIN : stamp解释：</span></span><br><span class="line"><span class="comment">    *假设stamp为：ORIGIN + WBIT(第一次获取了写锁的状态)</span></span><br><span class="line"><span class="comment">    *0000 0000 0000 0000  0000 0000 0000  0000 0000 0000 0000  0000 0001 1000 0000</span></span><br><span class="line"><span class="comment">    *那么加上一个WBIT之后位</span></span><br><span class="line"><span class="comment">    *0000 0000 0000 0000  0000 0000 0000  0000 0000 0000 0000  0000 0010 0000 0000</span></span><br><span class="line"><span class="comment">    *此时第八位已经为0，表示已经释放了写锁</span></span><br><span class="line"><span class="comment">    *但是随着这样累加上去可能最后会溢出结果64位全部为0，所以如果这种情况就置为ORIGIN</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    state = (stamp += WBIT) == <span class="number">0L</span> ? ORIGIN : stamp;</span><br><span class="line">    <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">        release(h); <span class="comment">//唤醒继承者节点线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在释放写锁时，如果stamp校验失败，则抛出异常；否则，释放锁，其实就是将<code>state的第8位置为0</code>，所以使用<code>state</code>加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^9</span><br></pre></td></tr></table></figure>
<p>即：</p>
<p>0000 0000 0000 0000  0000 0000 0000  0000 0000 0000 0000  0000 0010 0000 0000</p>
<p>即可将state的第8位置为0，达到释放锁的效果。因为<code>state</code>为long型，会发生溢出，64位全部为0，所以如果这种情况就置为ORIGIN。</p>
<h5 id="乐观读锁获取"><a href="#乐观读锁获取" class="headerlink" title="乐观读锁获取"></a>乐观读锁获取</h5><h6 id="tryOptimisticRead源码"><a href="#tryOptimisticRead源码" class="headerlink" title="tryOptimisticRead源码"></a>tryOptimisticRead源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryOptimisticRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> s; <span class="comment">//有写锁返回0.   否则返回256</span></span><br><span class="line">    <span class="keyword">return</span> (((s = state) &amp; WBIT) == <span class="number">0L</span>) ? (s &amp; SBITS) : <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取乐观锁的时候，如果没有写锁，则返回固定值<code>256</code>，否则返回0。<code>返回0表示获取锁失败</code>。</p>
<h6 id="validate源码"><a href="#validate源码" class="headerlink" title="validate源码"></a>validate源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    U.loadFence();  <span class="comment">//强制读取操作和验证操作在一些情况下的内存排序问题</span></span><br><span class="line">    <span class="keyword">return</span> (stamp &amp; SBITS) == (state &amp; SBITS);  <span class="comment">//当持有写锁后再释放写锁，该校验也不成立，返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在成功获取乐观锁并读取所需数据后，需要调用validate方法校验在读取期间是否发生了其他写锁（因为与SBITS进行&amp;操作时，只会检查8-64位，所以<code>(stamp &amp; SBITS) == (state &amp; SBITS)</code>时，说明期间没有发生新的写锁）。</p>
<h6 id="unlock源码"><a href="#unlock源码" class="headerlink" title="unlock源码"></a>unlock源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = stamp &amp; ABITS, m, s; WNode h;</span><br><span class="line">    <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;   <span class="comment">//有锁，state匹配stamp</span></span><br><span class="line">        <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>)  <span class="comment">//初始状态</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;   <span class="comment">//写锁</span></span><br><span class="line">            <span class="keyword">if</span> (a != m)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//s += WBIT， 第8位置为0</span></span><br><span class="line">            state = (s += WBIT) == <span class="number">0L</span> ? ORIGIN : s;</span><br><span class="line">            <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                release(h);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="number">0L</span> || a &gt;= WBIT)  <span class="comment">//表示没有锁</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;   <span class="comment">//读锁</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, s - RUNIT)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m == RUNIT &amp;&amp; (h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                    release(h);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果是读锁并且overflow</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tryDecReaderOverflow(s) != <span class="number">0L</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法释放的锁，既可以是读锁，也可以是写锁。首先，在stamp校验不通过时，直接抛异常；通过时</p>
<ul>
<li>若<code>state</code>为初始态，即没有锁时，抛异常；</li>
<li>为写锁时，当<code>a != m</code>时，抛异常；否则释放写锁，并唤醒后续节点。</li>
<li>若为读锁，并<code>m &lt; RFULL</code>，释放读锁并唤醒后续节点；否则减少overflow</li>
</ul>
<h6 id="tryConvertToWriteLock源码"><a href="#tryConvertToWriteLock源码" class="headerlink" title="tryConvertToWriteLock源码"></a>tryConvertToWriteLock源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> state匹配stamp时, 执行下列操作之一：</span></span><br><span class="line"><span class="comment">        1、stamp 已经持有写锁，直接返回.</span></span><br><span class="line"><span class="comment">        2、读模式，但是没有更多的读取者，并返回一个写锁stamp.</span></span><br><span class="line"><span class="comment">        3、有一个乐观读锁，只在即时可用的前提下返回一个写锁stamp</span></span><br><span class="line"><span class="comment">        4、其他情况都返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryConvertToWriteLock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//ABITS 1111 1111</span></span><br><span class="line">    <span class="comment">//SBITS 1000 0000</span></span><br><span class="line">    <span class="comment">//WBIT  1000 0000</span></span><br><span class="line">    <span class="comment">//RUNIT 0000 0001</span></span><br><span class="line">    <span class="keyword">long</span> a = stamp &amp; ABITS, m, s, next;</span><br><span class="line">    <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;  <span class="comment">//state匹配stamp</span></span><br><span class="line">        <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>) &#123;    <span class="comment">//没有锁</span></span><br><span class="line">            <span class="keyword">if</span> (a != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + WBIT))  <span class="comment">//CAS修改状态为持有写锁，并返回</span></span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;   <span class="comment">//持有写锁</span></span><br><span class="line">            <span class="keyword">if</span> (a != m) <span class="comment">//其他线程持有写锁</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">return</span> stamp;   <span class="comment">//当前线程已经持有写锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == RUNIT &amp;&amp; a != <span class="number">0L</span>) &#123;   <span class="comment">////有一个读锁</span></span><br><span class="line">            <span class="comment">//释放读锁，并尝试持有写锁</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s,</span><br><span class="line">                                     next = s - RUNIT + WBIT))</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法将读锁转为写锁。</p>
<h6 id="tryConvertToReadLock源码"><a href="#tryConvertToReadLock源码" class="headerlink" title="tryConvertToReadLock源码"></a>tryConvertToReadLock源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> state匹配stamp时, 执行下列操作之一.</span></span><br><span class="line"><span class="comment">     1、stamp 表示持有写锁，释放写锁，并持有读锁</span></span><br><span class="line"><span class="comment">     2 stamp 表示持有读锁 ，返回该读锁</span></span><br><span class="line"><span class="comment">     3 有一个乐观读锁，只在即时可用的前提下返回一个读锁stamp</span></span><br><span class="line"><span class="comment">     4、其他情况都返回0，表示失败</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">tryConvertToReadLock</span><span class="params">(<span class="keyword">long</span> stamp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a = stamp &amp; ABITS, m, s, next; WNode h;</span><br><span class="line">    <span class="keyword">while</span> (((s = state) &amp; SBITS) == (stamp &amp; SBITS)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((m = s &amp; ABITS) == <span class="number">0L</span>) &#123;    <span class="comment">//没有锁</span></span><br><span class="line">            <span class="keyword">if</span> (a != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m &lt; RFULL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, STATE, s, next = s + RUNIT))</span><br><span class="line">                    <span class="keyword">return</span> next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((next = tryIncReaderOverflow(s)) != <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (m == WBIT) &#123;   <span class="comment">//写锁</span></span><br><span class="line">            <span class="keyword">if</span> (a != m) <span class="comment">//非当前线程持有写锁</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            state = next = s + (WBIT + RUNIT);  <span class="comment">//释放写锁持有读锁</span></span><br><span class="line">            <span class="keyword">if</span> ((h = whead) != <span class="keyword">null</span> &amp;&amp; h.status != <span class="number">0</span>)</span><br><span class="line">                release(h);</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a != <span class="number">0L</span> &amp;&amp; a &lt; WBIT)   <span class="comment">//持有读锁</span></span><br><span class="line">            <span class="keyword">return</span> stamp;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法将写锁转为读锁。</p>
<ul>
<li>在没有任何锁的时候，如果<code>m &lt; RFULL</code>，则直接CAS获取读锁，否则增加<code>readerOverflow</code>。</li>
<li>在持有写锁时，则释放写锁持有读锁（<code>state = s + (WBIT + RUNIT)</code>）</li>
<li>在持有读锁时，直接返回<code>stamp</code>。</li>
</ul>
<h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="http://blog.csdn.net/luoyuyou/article/details/30259877" target="_blank" rel="noopener">深入理解StampedLock及其实现原理</a></p>
<p><a href="http://blog.csdn.net/huzhiqiangcsdn/article/details/76694836" target="_blank" rel="noopener">JDK1.8 StampedLock源码解析</a></p>
<p><a href="http://blog.5ibc.net/p/121849.html" target="_blank" rel="noopener">StampedLock实现浅析</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://houlong123.github.io/2017/10/15/java并发学习之StampedLock学习/" data-id="cjfguk7y9002ter0mt6gafsxf" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java并发锁/">java并发锁</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/01/Mysql根据指定数据确定分页/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Mysql根据指定数据确定分页
        
      </div>
    </a>
  
  
    <a href="/2017/09/28/ReentrantReadWriteLock源码学习/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">ReentrantReadWriteLock源码学习</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dokuwiki部署/">dokuwiki部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java基础集合/">java基础集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发/">java并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发锁/">java并发锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发集合/">java并发集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/部署GitHub-Page/">部署GitHub Page</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mysql/" style="font-size: 11.67px;">Mysql</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/dokuwiki部署/" style="font-size: 10px;">dokuwiki部署</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/java基础集合/" style="font-size: 20px;">java基础集合</a> <a href="/tags/java并发/" style="font-size: 13.33px;">java并发</a> <a href="/tags/java并发锁/" style="font-size: 16.67px;">java并发锁</a> <a href="/tags/java并发集合/" style="font-size: 18.33px;">java并发集合</a> <a href="/tags/部署GitHub-Page/" style="font-size: 10px;">部署GitHub Page</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/01/JVM额外知识学习/">JVM额外知识学习</a>
          </li>
        
          <li>
            <a href="/2018/03/20/Integer类学习/">Integer类学习</a>
          </li>
        
          <li>
            <a href="/2018/03/18/JVM-学习/">JVM 学习</a>
          </li>
        
          <li>
            <a href="/2018/02/26/TreeMap源码学习/">TreeMap源码学习</a>
          </li>
        
          <li>
            <a href="/2018/02/24/LinkedHashMap源码学习/">LinkedHashMap源码学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 houlong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
  <a href="https://github.com/houlong123"><img style="position: absolute; top: 0; right: 0; border: 0; z-index: 1000;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
</body>
</html>
