<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>ConcurrentLinkedQueue源码学习 | 而今伊始，命途自闯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言ConcurerntLinkedQueue一个 基于链接节点的无界线程安全的FIFO队列。和其他大部分并发集合类似，此队列不允许使用null元素。  源码解析内部数据结构123456789101112131415161718192021222324252627282930313233public class ConcurrentLinkedQueue&amp;lt;E&amp;gt; extends Abst">
<meta name="keywords" content="java并发集合">
<meta property="og:type" content="article">
<meta property="og:title" content="ConcurrentLinkedQueue源码学习">
<meta property="og:url" content="https://houlong123.github.io/2017/11/10/ConcurrentLinkedQueue源码学习/index.html">
<meta property="og:site_name" content="而今伊始，命途自闯">
<meta property="og:description" content="前言ConcurerntLinkedQueue一个 基于链接节点的无界线程安全的FIFO队列。和其他大部分并发集合类似，此队列不允许使用null元素。  源码解析内部数据结构123456789101112131415161718192021222324252627282930313233public class ConcurrentLinkedQueue&amp;lt;E&amp;gt; extends Abst">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531094819899-444696106.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531150623024-33105347.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531150707492-188834822.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531150752680-504185441.png">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531150752680-504185441.png">
<meta property="og:image" content="https://farm5.staticflickr.com/4525/37586647844_faa740949b_b.jpg">
<meta property="og:image" content="https://farm5.staticflickr.com/4537/38248234816_d7e10d86a5_b.jpg">
<meta property="og:image" content="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531150752680-504185441.png">
<meta property="og:image" content="https://farm5.staticflickr.com/4574/38271826052_4a02c44f22_b.jpg">
<meta property="og:updated_time" content="2018-01-25T06:56:26.292Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ConcurrentLinkedQueue源码学习">
<meta name="twitter:description" content="前言ConcurerntLinkedQueue一个 基于链接节点的无界线程安全的FIFO队列。和其他大部分并发集合类似，此队列不允许使用null元素。  源码解析内部数据结构123456789101112131415161718192021222324252627282930313233public class ConcurrentLinkedQueue&amp;lt;E&amp;gt; extends Abst">
<meta name="twitter:image" content="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531094819899-444696106.png">
  
    <link rel="alternate" href="/atom.xml" title="而今伊始，命途自闯" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">而今伊始，命途自闯</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://houlong123.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ConcurrentLinkedQueue源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/10/ConcurrentLinkedQueue源码学习/" class="article-date">
  <time datetime="2017-11-10T06:52:42.000Z" itemprop="datePublished">2017-11-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      ConcurrentLinkedQueue源码学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedQueue.html" target="_blank" rel="noopener">ConcurerntLinkedQueue</a><br>一个 <strong><code>基于链接节点的无界线程安全的FIFO队列</code></strong>。和其他大部分并发集合类似，此队列不允许使用null元素。</p>
<p><img src="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531094819899-444696106.png" alt="ConcurerntLinkedQueue数据结构"></p>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><h5 id="内部数据结构"><a href="#内部数据结构" class="headerlink" title="内部数据结构"></a>内部数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentLinkedQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//内部节点类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> E item;    <span class="comment">//表示元素</span></span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;  <span class="comment">//表示下一个结点</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;    <span class="comment">//头结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;    <span class="comment">//尾节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历器类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Next node to return item for.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; nextNode;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * nextItem holds on to item fields because once we claim</span></span><br><span class="line"><span class="comment">         * that an element exists in hasNext(), we must return it in</span></span><br><span class="line"><span class="comment">         * the following next() call even if it was in the process of</span></span><br><span class="line"><span class="comment">         * being removed when hasNext() was called.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> E nextItem;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Node of the last returned item, to support remove.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; lastRet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可知，<code>ConcurrentLinkedQueue</code> 继承了<code>AbstractQueue</code>抽象类并实现了<code>Queue</code> 与 <code>Serializable</code> 接口。其内部数据结构有：</p>
<a id="more"></a>
<ul>
<li><strong>内部类Node</strong>：Node是ConcurrentLinkedQueue存储结构的基本单元。</li>
<li><strong>迭代器类Itr</strong>：和大多数集合一样，都使用了迭代器模式，所以其内部提供一个元素遍历器。</li>
<li><p><strong>头尾节点</strong></p>
<ul>
<li><font color="red">head引用的不变性和可变性</font>

<ul>
<li><p>不变性(invariants)</p>
<ol>
<li>所有未删除节点，都能从head通过调用succ()方法遍历可达。</li>
<li>head头结点不能为null</li>
<li>head节点的next域不能引用到自身</li>
</ol>
</li>
<li><p>可变性(Non-invariants)</p>
<ol>
<li>head节点的item域可能为null，也可能不为null</li>
<li>允许tail滞后于head，即：从head开始遍历队列，不一定能到达tail</li>
</ol>
</li>
</ul>
</li>
<li><font color="red">tail 引用的不变性和可变性</font>

<ul>
<li><p>不变性(invariants)</p>
<ol>
<li>通过tail调用succ()方法，最后节点总是可达的</li>
<li>tail节点不能为null</li>
</ol>
</li>
<li><p>可变性(Non-invariants)</p>
<ol>
<li>tail节点的item域可能为null，也可能不为null</li>
<li>允许tail滞后于head，即：从head开始遍历队列，不一定能到达tail</li>
<li>tail节点的next域可以引用到自身</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认会构造一个 dummy 节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = <span class="keyword">null</span>, t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        checkNotNull(e);    <span class="comment">// 保证元素不为空</span></span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);   <span class="comment">// 新生一个结点</span></span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>)  <span class="comment">// 头结点为null</span></span><br><span class="line">            h = t = newNode;     <span class="comment">// 赋值头结点与尾结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            t.lazySetNext(newNode); <span class="comment">// 设置尾结点的next域</span></span><br><span class="line">            t = newNode;     <span class="comment">// 重新赋值尾结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>)</span><br><span class="line">        h = t = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    head = h;</span><br><span class="line">    tail = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由源码可知，<code>ConcurrentLinkedQueue</code> 提供了两个构造函数：无参构造函数和有参构造函数。</p>
<pre><code>无参构造函数只是简单的构造一个dummy节点，
  该结点的item域和next域都为null，然后头尾节点都指向这个dummy节点；

有参构造函数是使用参数集合构造一个ConcurrentLinkedQueue。
</code></pre><h5 id="add源码"><a href="#add源码" class="headerlink" title="add源码"></a>add源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在往队列中添加元素时，会调用add方法，add方法内部会调用offer方法。</p>
<h5 id="offer源码"><a href="#offer源码" class="headerlink" title="offer源码"></a>offer源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在队列的尾部添加元素。因队列是无界的，因此方法不会返回false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);  <span class="comment">//即将入队的元素不能为空</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);     <span class="comment">//创建节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于入队操作，采用失败即重试的方式，直到入队成功</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;   <span class="comment">// 初始化变量 p = t = tail</span></span><br><span class="line">        Node&lt;E&gt; q = p.next; <span class="comment">//q为p节点的next节点</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;    <span class="comment">// q结点为null，说明p为最后一个节点</span></span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123; <span class="comment">//CAS操作p的next节点</span></span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                <span class="comment">//在成功将newNode设置为p的next节点后，p指向</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time 每每经过一次 p = q 操作(向后遍历节点), 则 p != t 成立, 这个也说明 tail 滞后于 head 的体现</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)   <span class="comment">// 成立, 则说明p是pool()时调用 "updateHead" 导致的(删除头节点); 此时说明 tail 指针已经 fallen off queue</span></span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            <span class="comment">//在t != tail时，说明在多线程环境下，不但有线程操作了head节点，也有线程添加了新节点，所以p新赋值为tail；在t == tail 时，说明其他线程只进行了head节点的更新，所以p新赋值为head。然后在循环， 直到找到 node.next = null 的节点</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//在插入第二个节点时，才会更新tail节点</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>offer函数用于将指定元素插入此队列的尾部。大致逻辑为：</p>
<ol>
<li>判断指定元素是否为空，为空，抛出异常，方法结束</li>
<li>在指定元素不为空的情况下， 组装节点</li>
<li>采用失败即重试的方式，插入节点。<ol>
<li>获取尾节点p（p = tail）的next节点q</li>
<li>如果<code>q==null</code>，说明p节点为最后一个节点，则CAS进行设置p的next节点。设置成功后，如果又必须，则重新设置tail节点。方法结束。</li>
<li>如果 <code>p == q</code>，说明其他线程有调用了 <code>updateHead方法</code>，此时tail指针已<code>fallen off list</code>，则重新设置p指针，进行再次循环。</li>
<li>否则，也重新设置p指针，进行再次循环。</li>
</ol>
</li>
</ol>
<blockquote>
<p>单线程模拟入队操作</p>
</blockquote>
<ul>
<li><p>队列初始态</p>
<p>  <img src="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531150623024-33105347.png" alt="队列初始态"></p>
<p>  由源码可知，队列的初始化时，创建了一个dummy节点，且头尾节点都指向这个dummy节点。</p>
</li>
<li><p>元素10入队</p>
<p>  <img src="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531150707492-188834822.png" alt="入队后状态"></p>
<p>  由源码可知，在插入元素10时，由于tail节点的next节点为null，因此直接设置新节点为tail节点的next节点。在设置成功后，因为条件<code>p != t</code> 不成立，所以tail节点的指针不变。</p>
</li>
<li><p>元素20入队</p>
<p>  <img src="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531150752680-504185441.png" alt="入队后状态"></p>
<p>  由源码可知，在队列中只有元素10时，tail节点的next节点依然不为null，且条件<code>p == q</code>也不成立。所以执行<code>p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</code>，则<code>p = tail.next</code>。进入第二次循环。二次循环成功后，条件<code>p != t</code> 成立，所以tail节点的指针发送改变。即:<code>hop two nodes at a time</code>。</p>
</li>
</ul>
<h5 id="poll源码"><a href="#poll源码" class="headerlink" title="poll源码"></a>poll源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从队列的头结点取数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;    <span class="comment">// 若 node.item != null, 则进行cas操作, cas成功则返回值</span></span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time  //一次跳过两个节点</span></span><br><span class="line">                    updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);  <span class="comment">//进行 cas 更新 head ; "(q = p.next) != null" 怕出现p此时是尾节点了; 在 ConcurrentLinkedQueue 中正真的尾节点只有1个(必须满足node.next = null)</span></span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;    <span class="comment">//queue是空的, p是尾节点</span></span><br><span class="line">                updateHead(h, p);   <span class="comment">//这一步除了更新head 外, 还是helpDelete删除队列操作, 删除 p 之前的节点</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)    <span class="comment">//说明 p节点已经是删除了的head节点</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>poll函数用于获取并移除此队列的头，如果此队列为空，则返回null。。大致逻辑为：</p>
<ol>
<li>从头结点开始，将头结点赋值给变量p，循环队列</li>
<li>如果<code>p.item != null</code> 且CAS操作成功，则返回 p.item 的值。在返回值之前，需要判断是否需要更新头结点。</li>
<li>如果<code>p.next == null</code>，则调用<code>updateHead</code>方法设置头结点，然后返回</li>
<li>如果<code>p == q</code>，则说明p节点已是删除的头结点，则重新循环。</li>
<li>否则，设置<code>p = p.next</code>，继续循环。</li>
</ol>
<blockquote>
<p>单线程模拟出队操作</p>
</blockquote>
<ul>
<li><p>队列初始态</p>
<p>  <img src="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531150752680-504185441.png" alt="队列初始态"></p>
<p>  使用上面模拟入队后的队列</p>
</li>
<li><p>首次调用poll函数</p>
<p>  <a data-flickr-embed="true" href="https://www.flickr.com/photos/157389715@N05/37586647844/in/dateposted-public/" title="poll方法调用" target="_blank" rel="noopener"><img src="https://farm5.staticflickr.com/4525/37586647844_faa740949b_b.jpg" width="662" height="353" alt="poll方法调用"></a></p>
<p>  由源码可知，在首次调用poll函数时，由于头结点的item域为null，则执行<code>p = p.next</code>，然后再次循环。此时，节点的item域不为空，则返回item域值。在返回item域值之前，判断条件<code>p != h == true</code>，则调用<code>updateHead</code>方法设置头结点。</p>
</li>
<li><p>再次调用poll函数</p>
<p>  <a data-flickr-embed="true" href="https://www.flickr.com/photos/157389715@N05/38248234816/in/dateposted-public/" title="poll方法调用" target="_blank" rel="noopener"><img src="https://farm5.staticflickr.com/4537/38248234816_d7e10d86a5_b.jpg" width="662" height="353" alt="poll方法调用"></a></p>
<p>  由源码可知，再次调用poll方法时，头结点的item域不为空，所以直接返回item域的值，又因为条件<code>p != h = false</code>，所以头结点不会变更，只是头结点的item域变成了null。</p>
</li>
</ul>
<h5 id="updateHead源码"><a href="#updateHead源码" class="headerlink" title="updateHead源码"></a>updateHead源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to CAS head to p. If successful, repoint old head to itself</span></span><br><span class="line"><span class="comment"> * as sentinel for succ(), below.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 将节点 p设置为新的头节点(这是原子操作),成功之后将原头节点的next指向它自己, 直接变成一个哨兵节点(为queue节点删除及garbage做准备)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        h.lazySetNext(h);   <span class="comment">//将节点h变为哨兵节点，为queue节点删除及garbage做准备</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的功能是设置头结点。</p>
<h5 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;    <span class="comment">// 元素为null，返回</span></span><br><span class="line">    Node&lt;E&gt; pred = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p)) &#123; <span class="comment">// 获取第一个存活的结点</span></span><br><span class="line">        E item = p.item;    <span class="comment">// 第一个存活结点的item值</span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            o.equals(item) &amp;&amp;</span><br><span class="line">            p.casItem(item, <span class="keyword">null</span>)) &#123;    <span class="comment">// 找到item相等的结点，并且将该结点的item设置为null</span></span><br><span class="line">            Node&lt;E&gt; next = succ(p); <span class="comment">// p的后继结点</span></span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>)</span><br><span class="line">                pred.casNext(p, next);  <span class="comment">//在pred不为null且next不为null的时候，设置pred的next域</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pred = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数用于从队列中移除指定元素的单个实例（如果存在）。大致逻辑为从头结点开始遍历，如果item域值为指定元素，则将对于的item域置为null，否则获取下一节点，循环处理。</p>
<h5 id="first源码"><a href="#first源码" class="headerlink" title="first源码"></a>first源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回队列中第一个没有被删除的节点，另一个版本的poll/peek方法</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 无限循环，确保成功</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasItem = (p.item != <span class="keyword">null</span>); <span class="comment">// p结点的item域是否为null</span></span><br><span class="line">            <span class="keyword">if</span> (hasItem || (q = p.next) == <span class="keyword">null</span>) &#123;      <span class="comment">// item不为null或者next域为null</span></span><br><span class="line">                updateHead(h, p);   <span class="comment">// 更新头结点</span></span><br><span class="line">                <span class="keyword">return</span> hasItem ? p : <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)     <span class="comment">//说明 p节点已经是删除了的head节点</span></span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;   <span class="comment">// p赋值为p.next，再次循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>first函数用于找到链表中第一个存活的结点。</p>
<h5 id="succ方法"><a href="#succ方法" class="headerlink" title="succ方法"></a>succ方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the successor of p, or the head node if p.next has been</span></span><br><span class="line"><span class="comment"> * linked to self, which will only be true if traversing with a</span></span><br><span class="line"><span class="comment"> * stale pointer that is now off the list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果p.next已链接到p本身自己，则返回头节点；否则返回p的后继节点。</span></span><br><span class="line"><span class="comment"> * p == p.next 只有在使用不在列表中的陈旧指针进行遍历时，才会返回true</span></span><br><span class="line"><span class="comment"> * p.next == p 是 updateHead() 操作导致的。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;E&gt; <span class="title">succ</span><span class="params">(Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在并发队列中，node.next并不一定就是node的后继节点，还有一种特殊情况，就是node指向一个哨兵节点，该哨兵节点为queue节点删除及garbage做准备</span></span><br><span class="line">    Node&lt;E&gt; next = p.next;</span><br><span class="line">    <span class="keyword">return</span> (p == next) ? head : next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>succ方法用于获取结点的下一个结点。如果结点的next域指向自身，则返回head头结点，否则，返回next结点。</p>
<blockquote>
<p>模拟remove方法调用</p>
</blockquote>
<ul>
<li><p>队列初始态</p>
<p>  <img src="http://images2015.cnblogs.com/blog/616953/201605/616953-20160531150752680-504185441.png" alt="队列初始态"></p>
<p>  使用上面模拟入队后的队列</p>
</li>
<li><p>执行remove(10)</p>
<p>  <a data-flickr-embed="true" href="https://www.flickr.com/photos/157389715@N05/38271826052/in/dateposted-public/" title="remove方法调用" target="_blank" rel="noopener"><img src="https://farm5.staticflickr.com/4574/38271826052_4a02c44f22_b.jpg" width="662" height="353" alt="remove方法调用"></a></p>
<p>  由源码可知，在调用remove方法时，会先调用first方法获取队列的头元素，在first方法的时候，由于<code>p.item != null = false</code> 且 <code>(q = p.next == null) = false</code>，所以执行<code>p = p.next</code>，进入二次循环。在二次循环时，会执行<code>updateHead</code>设置头结点。所以原头结点被特殊处理，等后续清理。</p>
</li>
</ul>
<h5 id="size方法"><a href="#size方法" class="headerlink" title="size方法"></a>size方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Additionally, if elements are added or removed during execution</span></span><br><span class="line"><span class="comment"> * of this method, the returned result may be inaccurate.  Thus,</span></span><br><span class="line"><span class="comment"> * this method is typically not very useful in concurrent</span></span><br><span class="line"><span class="comment"> * applications.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p))    <span class="comment">// 从第一个存活的结点开始往后遍历</span></span><br><span class="line">        <span class="keyword">if</span> (p.item != <span class="keyword">null</span>)  <span class="comment">// 结点的item域不为null</span></span><br><span class="line">            <span class="comment">// Collection.size() spec says to max out</span></span><br><span class="line">            <span class="keyword">if</span> (++count == Integer.MAX_VALUE)   <span class="comment">// 增加计数，若达到最大值，则跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数用于返回ConcurrenLinkedQueue的大小，从第一个存活的结点（first）开始，往后遍历链表，当结点的item域不为null时，增加计数，之后返回大小。该方法在多线程情况下，并没有多大用处。</p>
<h5 id="contains方法"><a href="#contains方法" class="headerlink" title="contains方法"></a>contains方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p)) &#123;     <span class="comment">//循环遍历队列</span></span><br><span class="line">        E item = p.item;</span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; o.equals(item))     <span class="comment">//在节点的item值与指导元素相等时，返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h4><p><a href="http://www.cnblogs.com/leesf456/p/5539142.html" target="_blank" rel="noopener">JDK1.8源码分析之ConcurrentLinkedQueue（五）</a></p>
<p><a href="http://www.jianshu.com/p/08e8b0c424c0" target="_blank" rel="noopener">ConcurrentLinkedQueue 源码分析 (基于Java 8)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://houlong123.github.io/2017/11/10/ConcurrentLinkedQueue源码学习/" data-id="cjew9q8yt000hzb0m19tmt0tn" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java并发集合/">java并发集合</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/11/14/CopyOnWriteArrayList源码学习/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          CopyOnWriteArrayList源码学习
        
      </div>
    </a>
  
  
    <a href="/2017/11/07/ConcurrentHashMap源码学习/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">ConcurrentHashMap源码学习</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dokuwiki部署/">dokuwiki部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java基础集合/">java基础集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发/">java并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发锁/">java并发锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发集合/">java并发集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/部署GitHub-Page/">部署GitHub Page</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mysql/" style="font-size: 11.67px;">Mysql</a> <a href="/tags/Spring/" style="font-size: 15px;">Spring</a> <a href="/tags/dokuwiki部署/" style="font-size: 10px;">dokuwiki部署</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 16.67px;">java</a> <a href="/tags/java基础集合/" style="font-size: 20px;">java基础集合</a> <a href="/tags/java并发/" style="font-size: 13.33px;">java并发</a> <a href="/tags/java并发锁/" style="font-size: 16.67px;">java并发锁</a> <a href="/tags/java并发集合/" style="font-size: 18.33px;">java并发集合</a> <a href="/tags/部署GitHub-Page/" style="font-size: 10px;">部署GitHub Page</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/18/JVM-学习/">JVM 学习</a>
          </li>
        
          <li>
            <a href="/2018/02/26/TreeMap源码学习/">TreeMap源码学习</a>
          </li>
        
          <li>
            <a href="/2018/02/24/LinkedHashMap源码学习/">LinkedHashMap源码学习</a>
          </li>
        
          <li>
            <a href="/2018/02/02/HashMap源码学习/">HashMap源码学习</a>
          </li>
        
          <li>
            <a href="/2018/01/30/AbstractMap源码学习/">AbstractMap源码学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 houlong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
  <a href="https://github.com/houlong123"><img style="position: absolute; top: 0; right: 0; border: 0; z-index: 1000;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
</body>
</html>
