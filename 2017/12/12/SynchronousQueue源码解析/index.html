<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>SynchronousQueue源码解析 | 而今伊始，命途自闯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言SynchronousQueue是BlockingQueue阻塞队列的一种实现。但是作为阻塞队列的一种，SynchronousQueue与其他BlockingQueue有着不同特性：  SynchronousQueue没有容量(A synchronous queue does not have any internal capacity, not even a capacity of one.">
<meta name="keywords" content="java并发集合">
<meta property="og:type" content="article">
<meta property="og:title" content="SynchronousQueue源码解析">
<meta property="og:url" content="https://houlong123.github.io/2017/12/12/SynchronousQueue源码解析/index.html">
<meta property="og:site_name" content="而今伊始，命途自闯">
<meta property="og:description" content="前言SynchronousQueue是BlockingQueue阻塞队列的一种实现。但是作为阻塞队列的一种，SynchronousQueue与其他BlockingQueue有着不同特性：  SynchronousQueue没有容量(A synchronous queue does not have any internal capacity, not even a capacity of one.">
<meta property="og:updated_time" content="2018-01-25T07:11:40.696Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SynchronousQueue源码解析">
<meta name="twitter:description" content="前言SynchronousQueue是BlockingQueue阻塞队列的一种实现。但是作为阻塞队列的一种，SynchronousQueue与其他BlockingQueue有着不同特性：  SynchronousQueue没有容量(A synchronous queue does not have any internal capacity, not even a capacity of one.">
  
    <link rel="alternate" href="/atom.xml" title="而今伊始，命途自闯" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">而今伊始，命途自闯</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://houlong123.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-SynchronousQueue源码解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/12/SynchronousQueue源码解析/" class="article-date">
  <time datetime="2017-12-12T07:09:27.000Z" itemprop="datePublished">2017-12-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      SynchronousQueue源码解析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>SynchronousQueue是BlockingQueue阻塞队列的一种实现。但是作为阻塞队列的一种，SynchronousQueue与其他BlockingQueue有着不同特性：</p>
<ol>
<li>SynchronousQueue没有容量(<code>A synchronous queue does not have any internal capacity, not even a capacity of one.</code>)。所以其内部方法：<code>isEmpty</code>，<code>size</code>，<code>clear</code>，<code>contains</code>，<code>remove</code>都是默认实现。</li>
<li>SynchronousQueue分为公平（队列实现）和非公平（栈实现）策略。默认情况下采用非公平性访问策略。</li>
</ol>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractQueue</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">BlockingQueue</span>&lt;<span class="title">E</span>&gt;, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 可用的处理器</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NCPUS = Runtime.getRuntime().availableProcessors();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大空旋时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxTimedSpins = (NCPUS &lt; <span class="number">2</span>) ? <span class="number">0</span> : <span class="number">32</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 无限时的等待的最大空旋时间</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> maxUntimedSpins = maxTimedSpins * <span class="number">16</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 超时空旋等待阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> spinForTimeoutThreshold = <span class="number">1000L</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Transferer&lt;E&gt; transferer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//非公平策略实现类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 表示消费数据的消费者</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 表示生产数据的生产者</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//表示该操作节点处于真正匹配状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//内部节点类</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公平策略实现类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//队列头</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">        <span class="comment">//队列尾</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line">        <span class="comment">//当要删除的节点为队列中最后一个元素时，会引用到这个节点</span></span><br><span class="line">        <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//内部节点类</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部抽象类，其公平/非公平策略都是基于该类</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs a put or take.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> e if non-null, the item to be handed to a consumer;</span></span><br><span class="line"><span class="comment">         *          if null, requests that transfer return an item</span></span><br><span class="line"><span class="comment">         *          offered by producer.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> timed if this operation should timeout</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> nanos the timeout, in nanoseconds</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> if non-null, the item provided or received; if null,</span></span><br><span class="line"><span class="comment">         *         the operation failed due to timeout or interrupt --</span></span><br><span class="line"><span class="comment">         *         the caller can distinguish which of these occurred</span></span><br><span class="line"><span class="comment">         *         by checking Thread.interrupted.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 转移数据，put或者take操作</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由源码可知，SynchronousQueue阻塞队列的内部，有一个<code>Transferer接口</code>，该接口中的API由队列（公平策略）/栈（非公平策略）共同使用，实现不同功能。SynchronousQueue队列的所有功能操作都是通过<code>Transferer</code>对象来实现的。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SynchronousQueue</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 fair 值来决定内部用 使用 queue 还是 stack 存储线程节点。队列是公平的</span></span><br><span class="line">    transferer = fair ? <span class="keyword">new</span> TransferQueue&lt;E&gt;() : <span class="keyword">new</span> TransferStack&lt;E&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从构造函数中可知，<code>SynchronousQueue</code>阻塞队列的默认实现方式是<code>TransferStack(非公平策略)</code>，我们可以通过传递参数来决定使用何种阻塞队列实现策略。</p>
<h4 id="put-源码"><a href="#put-源码" class="headerlink" title="put 源码"></a>put 源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将指定元素添加到此队列，如有必要则等待另一个线程接收它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//元素e为空，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123; <span class="comment">// 进行转移操作</span></span><br><span class="line">        Thread.interrupted();   <span class="comment">// 中断当前线程</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由源码可知，<code>SynchronousQueue</code>阻塞队列不允许存储为<code>null</code>的元素。然后操作转给<code>Transfer</code>对象去处理，具体的处理细节，详见下面的分析。</p>
<h4 id="offer源码"><a href="#offer源码" class="headerlink" title="offer源码"></a>offer源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(e, <span class="keyword">true</span>, <span class="number">0</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时offer源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//元素e为空，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//进行转移操作</span></span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(e, <span class="keyword">true</span>, unit.toNanos(timeout)) != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!Thread.interrupted())  <span class="comment">// 当前线程没有被中断</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>offer的源码实现与put的源码实现很类似。不在分析。</p>
<h4 id="take源码"><a href="#take源码" class="headerlink" title="take源码"></a>take源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取并移除此队列的头，如有必要则等待另一个线程插入它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>);  <span class="comment">// 进行转移操作</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用 <code>take</code> 从阻塞队列中获取元素时，也是通过<code>Transfer</code>对象去处理。在获取的元素不为null时，直接返回；否则，中断并抛出异常。</p>
<h4 id="poll源码"><a href="#poll源码" class="headerlink" title="poll源码"></a>poll源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果另一个线程当前正要使用某个元素，则获取并移除此队列的头</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//超时poll源码</span></span><br><span class="line"><span class="comment">// 获取并移除此队列的头，如有必要则等待指定的时间，以便另一个线程插入它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> || !Thread.interrupted())  <span class="comment">// 元素不为null或者当前线程没有被中断</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，具体实现也是通过<code>Transfer</code>对象。</p>
<p>由上面的源码可知，阻塞队列SynchronousQueue的有关操作，都是通过内部接口<code>Transfer</code>的实现类来间接完成的。<code>Transfer接口</code>的实现类有两个，即两种模式：</p>
<ol>
<li><p>公平模式</p>
<p> 所谓公平就是遵循 <code>先来先服务</code> 的原则，因此其内部使用了一个FIFO队列 来实现其功能。</p>
</li>
<li><p>非公平模式</p>
<p> SynchronousQueue 中的非公平模式是默认的模式，其内部使用栈来实现其功能，也就是 <code>后来的先服务</code>。</p>
</li>
</ol>
<h4 id="公平模式-TransferQueue"><a href="#公平模式-TransferQueue" class="headerlink" title="公平模式 TransferQueue"></a>公平模式 TransferQueue</h4><h5 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Dual Queue */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  这是一个典型的 queue , 它有如下的特点</span></span><br><span class="line"><span class="comment"> *  1. 整个队列有 head, tail 两个节点</span></span><br><span class="line"><span class="comment"> *  2. 队列初始化时会有个 dummy 节点</span></span><br><span class="line"><span class="comment"> *  3. 这个队列的头节点是个 dummy 节点/ 或 哨兵节点, 所以操作的总是队列中的第二个节点(AQS的设计中也是这也)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferQueue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列头</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line">    <span class="comment">//队列尾</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line">    <span class="comment">//当要删除的节点为队列中最后一个元素时，会引用到这个节点</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> QNode cleanMe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单元节点类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">QNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> QNode next;          <span class="comment">// next node in queue</span></span><br><span class="line">        <span class="keyword">volatile</span> Object item;         <span class="comment">// CAS'ed to or from null</span></span><br><span class="line">        <span class="keyword">volatile</span> Thread waiter;       <span class="comment">// to control park/unpark</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在队列中，内部有个<code>QNode</code>类，代表的是队列中的一个存储节点。在该类的内部没有使用锁，而是通过cas算法来完成原子操作。</p>
<h5 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TransferQueue() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造一个 dummy node, 而整个 queue 中永远会存在这样一个 dummy node</span></span><br><span class="line"><span class="comment">     * dummy node 的存在使得 代码中不存在复杂的 if 条件判断</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QNode h = <span class="keyword">new</span> QNode(<span class="keyword">null</span>, <span class="keyword">false</span>); <span class="comment">// initialize to dummy node.</span></span><br><span class="line">    head = h;</span><br><span class="line">    tail = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransferQueue的构造函数，构造了一个哨兵节点，然后头尾节点都指向这个哨兵节点。</p>
<h5 id="transfer源码"><a href="#transfer源码" class="headerlink" title="transfer源码"></a>transfer源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Puts or takes an item.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Basic algorithm is to loop trying to take either of</span></span><br><span class="line"><span class="comment">     * two actions:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. If queue apparently empty or holding same-mode nodes,</span></span><br><span class="line"><span class="comment">     *    try to add node to queue of waiters, wait to be</span></span><br><span class="line"><span class="comment">     *    fulfilled (or cancelled) and return matching item.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2. If queue apparently contains waiting items, and this</span></span><br><span class="line"><span class="comment">     *    call is of complementary mode, try to fulfill by CAS'ing</span></span><br><span class="line"><span class="comment">     *    item field of waiting node and dequeuing it, and then</span></span><br><span class="line"><span class="comment">     *    returning matching item.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In each case, along the way, check for and try to help</span></span><br><span class="line"><span class="comment">     * advance head and tail on behalf of other stalled/slow</span></span><br><span class="line"><span class="comment">     * threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The loop starts off with a null check guarding against</span></span><br><span class="line"><span class="comment">     * seeing uninitialized head or tail values. This never</span></span><br><span class="line"><span class="comment">     * happens in current SynchronousQueue, but could if</span></span><br><span class="line"><span class="comment">     * callers held non-volatile/final ref to the</span></span><br><span class="line"><span class="comment">     * transferer. The check is here anyway because it places</span></span><br><span class="line"><span class="comment">     * null checks at top of loop, which is usually faster</span></span><br><span class="line"><span class="comment">     * than having them implicitly interspersed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    QNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line">    <span class="comment">// 确定此次转移的类型（put or take）</span></span><br><span class="line">    <span class="keyword">boolean</span> isData = (e != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        QNode t = tail; <span class="comment">// 获取尾结点</span></span><br><span class="line">        QNode h = head; <span class="comment">//获取头结点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化的队头和队尾都是指向的一个"空" 节点，不会是null</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span> || h == <span class="keyword">null</span>)       <span class="comment">// 看到未初始化的头尾结点  // saw uninitialized value</span></span><br><span class="line">            <span class="keyword">continue</span>;                       <span class="comment">// spin</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123; <span class="comment">//入队操作。 队列为空 或者 尾结点的模式与当前结点模式相同,即上次和本次是同样的操作：入队或者出队。每一个入队和出队是互相匹配的  // empty or same-mode</span></span><br><span class="line">            <span class="comment">// 获取尾结点的next域</span></span><br><span class="line">            QNode tn = t.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存在并发，队列被修改了，从头开始</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)                  <span class="comment">// t不为尾结点，不一致，有并发，重试  // inconsistent read</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//队列被修改了，tail不是队尾，则辅助推进tail</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;           <span class="comment">//tn不为null，有其他线程添加了tail的next结点，帮助推进 tail    // lagging tail</span></span><br><span class="line">                <span class="comment">// 设置新的尾结点为tn</span></span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果进行了超时等待操作，发生超时则返回NULL</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)    <span class="comment">// 设置了timed并且等待时间小于等于0，表示不能等待，需要立即操作    // can't wait</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> QNode(e, isData);   <span class="comment">// 新生一个结点并赋值给s</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将新节点 cas 设置成tail的后继 ,失败则重来</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="keyword">null</span>, s))   <span class="comment">// 将 新建的节点加入到 队列中  // failed to link in</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加了一个节点，推进队尾指针，将队尾指向新加入的节点</span></span><br><span class="line">            advanceTail(t, s);              <span class="comment">// swing tail and wait</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 空旋或者阻塞直到有匹配操作，即s结点被匹配</span></span><br><span class="line">            Object x = awaitFulfill(s, e, timed, nanos);    <span class="comment">// 调用awaitFulfill, 若节点是 head.next, 则进行一些自旋, 若不是的话, 直接 block, 知道有其他线程 与之匹配, 或它自己进行线程的中断</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果操作被取消</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;          <span class="comment">// x与s相等，表示已经取消         // wait was cancelled</span></span><br><span class="line">                clean(t, s);    <span class="comment">// 清除</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//匹配的操作到来，s操作完成，离开队列，如果没离开，使其离开</span></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;           <span class="comment">// not already unlinked</span></span><br><span class="line">                <span class="comment">//推进head ,cas将head 由t(是t不是h)，设置为s</span></span><br><span class="line">                advanceHead(t, s);          <span class="comment">// unlink if head</span></span><br><span class="line">                <span class="comment">// x不为null</span></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="keyword">null</span>)              <span class="comment">// and forget fields</span></span><br><span class="line">                    <span class="comment">// 设置s结点的item</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                <span class="comment">// 设置s结点的waiter域为null</span></span><br><span class="line">                s.waiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 模式互补。不同的模式那么是匹配的（put 匹配take ，take匹配put），出队操作             // complementary-mode</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取头结点的next域（匹配的结点）。 这里是从head.next开始，因为TransferQueue总是会存在一个dummy node节点</span></span><br><span class="line">            QNode m = h.next;               <span class="comment">// node to fulfill</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//队列发生变化，重来</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="keyword">null</span> || h != head)    <span class="comment">// t不为尾结点或者m为null或者h不为头结点（不一致）</span></span><br><span class="line">                <span class="keyword">continue</span>;                   <span class="comment">// inconsistent read</span></span><br><span class="line"></span><br><span class="line">            Object x = m.item;  <span class="comment">// 获取m结点的元素域</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果isData == (x != null) 为true 那么表示是相同的操作。</span></span><br><span class="line">            <span class="comment">//x==m 则是被取消了的操作</span></span><br><span class="line">            <span class="comment">//m.casItem(x, e) 将m的item设置为本次操作的数据域</span></span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="keyword">null</span>) ||    <span class="comment">// m结点被匹配 // m already fulfilled</span></span><br><span class="line">                x == m ||                   <span class="comment">// m结点被取消 // m cancelled</span></span><br><span class="line">                !m.casItem(x, e)) &#123;         <span class="comment">// CAS操作失败 // lost CAS</span></span><br><span class="line">                advanceHead(h, m);          <span class="comment">// 队列头结点出队列，并重试 // dequeue and retry</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 匹配成功，设置新的头结点</span></span><br><span class="line">            advanceHead(h, m);              <span class="comment">// successfully fulfilled</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 唤醒匹配操作的线程</span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="keyword">return</span> (x != <span class="keyword">null</span>) ? (E)x : e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要逻辑：</p>
<ol>
<li>通过判断元素e，来确认当前操作类型。（在元素e为null时，则表示消费（take操作）；在元素e不为null时，则表示生产（put操作））</li>
<li>进入无限循环</li>
<li>获取头尾节点，若没有初始化，则 <code>continue</code> 继续。</li>
<li>如果队列为空或者尾结点的模式与当前结点模式相同，则进行入队操作。执行下面新步骤，否则执行第5步骤。<ol>
<li>获取尾节点的next域 <code>tn</code></li>
<li>如果队列存在并发，则 <code>continue</code> 继续。</li>
<li>如果 <code>tn 不为null</code>，说明有并发，则辅助推进tail节点，然后 <code>continue</code> 继续。</li>
<li>如果超时，则直接返回null</li>
<li>将元素e组装成节点s</li>
<li>将节点s设置为队列尾节点的next节点。如果成功，执行第7步骤，否则， <code>continue</code> 继续。</li>
<li>将节点s设置为队列尾节点</li>
<li>调用<code>awaitFulfill</code>方法，空旋或者阻塞直到有匹配操作。</li>
<li>如果操作被取消，则清除节点s，并返回null</li>
<li>判断节点s是否脱离队列，脱离，返回元素，方法结束；否则辅助节点s脱离队列。</li>
</ol>
</li>
<li>执行至此，说明当前操作与上次操作匹配（put 匹配take ，take匹配put），进行出队操作。<ol>
<li>获取头节点的next域m节点</li>
<li>如果有并发情景，则<code>continue</code> 继续。</li>
<li>获取m节点的item域</li>
<li>如果 m节点已被匹配或者m节点被取消或者CAS操作m节点的item域失败，在重新设置队列的头元素，并<code>continue</code> 继续。</li>
<li>匹配成功，重新设置队列的头元素</li>
<li>唤醒匹配操作的线程</li>
<li>返回元素</li>
</ol>
</li>
</ol>
<h5 id="awaitFulfill源码"><a href="#awaitFulfill源码" class="headerlink" title="awaitFulfill源码"></a>awaitFulfill源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主逻辑: 若节点是 head.next 则进行 spins 一会, 若不是, 则调用 LockSupport.park / parkNanos(), 直到其他的线程对其进行唤醒</span></span><br><span class="line"><span class="function">Object <span class="title">awaitFulfill</span><span class="params">(QNode s, E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;          <span class="comment">// s 是刚刚入队的操作节点，e是操作（也可说是数据）</span></span><br><span class="line">    <span class="comment">/* Same idea as TransferStack.awaitFulfill */</span></span><br><span class="line">    <span class="comment">// 根据timed标识计算截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 计算空旋时间</span></span><br><span class="line">    <span class="keyword">int</span> spins = ((head.next == s) ?</span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);    <span class="comment">//若当前节点为head.next时才进行自旋</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前线程发生中断，那么尝试取消该操作</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())</span><br><span class="line">            s.tryCancel(e); <span class="comment">// 若线程中断, 直接将 item 设置成了 this, 在 transfer 中会对返回值进行判断</span></span><br><span class="line"></span><br><span class="line">        Object x = s.item;  <span class="comment">// 获取s的元素域</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// s.item ！=e则返回，生成s节点的时候，s.item是等于e的，当取消操作或者匹配了操作的时候会进行更改。匹配对应transfer方法中的 m.casItem(x, e) 代码</span></span><br><span class="line">        <span class="keyword">if</span> (x != e) <span class="comment">// 在进行线程阻塞-&gt;唤醒, 线程中断, 等待超时, 这时 x != e,直接return 回去</span></span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果设置了超时等待</span></span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;    <span class="comment">// 设置了timed</span></span><br><span class="line">            nanos = deadline - System.nanoTime();   <span class="comment">// 计算继续等待的时间</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//发生了超时，尝试取消该操作</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">//将s的item域指向this实现取消操作</span></span><br><span class="line">                s.tryCancel(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//自旋控制</span></span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)  <span class="comment">// 空旋时间大于0，空旋</span></span><br><span class="line">            --spins;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置等待线程 waiter</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 设置等待线程</span></span><br><span class="line">            s.waiter = w;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            <span class="comment">// 禁用当前线程并设置了阻塞者</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)   <span class="comment">//自旋次数过了, 直接 + timeout 方式 park</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法应该比较好理解，就是等待匹配操作的到来，如果设置了超时等待，那么就等待一定时间，如果发生超时，那么就取消该操作，如果没有设置超时等待，那么就一直等待，直到匹配的操作到来，或者发生中断（取消该操作）。</p>
<h5 id="clean源码"><a href="#clean源码" class="headerlink" title="clean源码"></a>clean源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于移除已经被取消的结点。pred 是s的前驱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(QNode pred, QNode s)</span> </span>&#123;</span><br><span class="line">    s.waiter = <span class="keyword">null</span>; <span class="comment">// forget thread</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At any given time, exactly one node on list cannot be</span></span><br><span class="line"><span class="comment">     * deleted -- the last inserted node. To accommodate this,</span></span><br><span class="line"><span class="comment">     * if we cannot delete s, we save its predecessor as</span></span><br><span class="line"><span class="comment">     * "cleanMe", deleting the previously saved version</span></span><br><span class="line"><span class="comment">     * first. At least one of node s or the node previously</span></span><br><span class="line"><span class="comment">     * saved can always be deleted, so this always terminates.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (pred.next == s) &#123; <span class="comment">// pred的next域为s // Return early if already unlinked</span></span><br><span class="line">        QNode h = head; <span class="comment">// 获取头结点</span></span><br><span class="line">        <span class="comment">// 获取头结点的next域</span></span><br><span class="line">        QNode hn = h.next;   <span class="comment">// Absorb cancelled first node as head</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//操作取消了，那么推进head</span></span><br><span class="line">        <span class="keyword">if</span> (hn != <span class="keyword">null</span> &amp;&amp; hn.isCancelled()) &#123;   <span class="comment">// hn不为null并且hn被取消，重新设置头结点</span></span><br><span class="line">            advanceHead(h, hn);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取尾结点，保证对尾结点的读一致性</span></span><br><span class="line">        QNode t = tail;      <span class="comment">// Ensure consistent read for tail</span></span><br><span class="line">        <span class="keyword">if</span> (t == h) <span class="comment">// 尾结点为头结点，表示队列为空</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取尾结点的next域</span></span><br><span class="line">        QNode tn = t.next;</span><br><span class="line">        <span class="keyword">if</span> (t != tail)  <span class="comment">// t不为尾结点，不一致，重试</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//tn 理应为null ,如果不为空，说明其它线程进行了入队操作，更新tail</span></span><br><span class="line">        <span class="keyword">if</span> (tn != <span class="keyword">null</span>) &#123;   <span class="comment">//tn不为null ，说明其他线程修改了尾节点</span></span><br><span class="line">            advanceTail(t, tn); <span class="comment">//设置新的尾节点</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s!=t ,则s不是尾节点了，本来最开始是尾节点，其它线程进行了入队操作</span></span><br><span class="line">        <span class="keyword">if</span> (s != t) &#123;   <span class="comment">// s不为尾结点，移除s      // If not tail, try to unsplice</span></span><br><span class="line">            QNode sn = s.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果s.next ==s ,则已经离开队列</span></span><br><span class="line">            <span class="comment">//设置pred的后继为s的后继，将s从队列中删除</span></span><br><span class="line">            <span class="keyword">if</span> (sn == s || pred.casNext(s, sn))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到这里，那么s就是队尾，那么暂时不能删除</span></span><br><span class="line">        <span class="comment">//cleanMe标识的是需要删除节点的前驱</span></span><br><span class="line">        QNode dp = cleanMe;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有需要删除的节点</span></span><br><span class="line">        <span class="keyword">if</span> (dp != <span class="keyword">null</span>) &#123; <span class="comment">// dp不为null，断开前面被取消的结点   // Try unlinking previous cancelled node</span></span><br><span class="line">            QNode d = dp.next;</span><br><span class="line">            QNode dn;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * cleamMe 失效的情况有：</span></span><br><span class="line"><span class="comment">             *   (1)cleanMe的后继而空（cleanMe 标记的是需要删除节点的前驱）</span></span><br><span class="line"><span class="comment">             *   (2)cleanMe的后继等于自身（这个前面有分析过）</span></span><br><span class="line"><span class="comment">             *   (3)需要删除节点的操作没有被取消</span></span><br><span class="line"><span class="comment">             *   (4)被删除的节点不是尾节点且其后继节点有效，并将待删除节点删除</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">             <span class="keyword">if</span> (d == <span class="keyword">null</span> ||               <span class="comment">// d is gone or</span></span><br><span class="line">                d == dp ||                 <span class="comment">// d is off list or</span></span><br><span class="line">                !d.isCancelled() ||        <span class="comment">// d not cancelled or</span></span><br><span class="line">                (d != t &amp;&amp;                 <span class="comment">// d not tail and</span></span><br><span class="line">                 (dn = d.next) != <span class="keyword">null</span> &amp;&amp;  <span class="comment">//   has successor</span></span><br><span class="line">                 dn != d &amp;&amp;                <span class="comment">//   that is on list</span></span><br><span class="line">                 dp.casNext(d, dn)))       <span class="comment">// d unspliced</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//清除cleanMe节点</span></span><br><span class="line">                casCleanMe(dp, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//dp==pred 表示已经被设置过了</span></span><br><span class="line">            <span class="keyword">if</span> (dp == pred)</span><br><span class="line">                <span class="keyword">return</span>;      <span class="comment">// s is already saved node</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casCleanMe(<span class="keyword">null</span>, pred))  <span class="comment">// 原来的 cleanMe 是 null, 则将 pred 标记为 cleamMe 为下次 清除 s 节点做标识</span></span><br><span class="line">            <span class="keyword">return</span>;          <span class="comment">// Postpone cleaning s</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表的删除只需要设置节点指针的关系就可以了，这个clean的方法就在链表基础上增加了一个逻辑：就是如果删除的节点不是尾节点，那么可以直接进行删除，如果删除的节点是尾节点，那么用cleanMe标记需要删除的节点的前驱，这样在下一轮的clean的过程将会清除打了标记的节点。 </p>
<ol>
<li>pred.next == s 表示节点s还在队列中 </li>
<li>从队头开始，如果节点被取消，那么则推进head。 </li>
<li>如果队列发生变化，则重新开始或者推进tail. </li>
<li>如果删除的节点不是尾节点，那么进行cas 删除操作 </li>
<li>删除的节点是尾节点，那么需要先检查cleanMe是否已经被标记了 </li>
<li>如果cleanMe已经被标记了，那么检查标记是否还有效 </li>
<li>cleamMe 失效的情况有：(1)cleanMe的后继而空（cleanMe 标记的是需要删除节点的前驱），(2)cleanMe的后继等于自身（这个前面有分析过）,(3)需要删除节点的操作没有被取消，(4)被删除的节点不是尾节点且其后继节点有效。 </li>
<li>如果cleanMe没有被标记，那么就标记为被删除节点的前驱。</li>
</ol>
<h4 id="公平队列SynchronousQueue-总结"><a href="#公平队列SynchronousQueue-总结" class="headerlink" title="公平队列SynchronousQueue 总结"></a>公平队列SynchronousQueue 总结</h4><p>公平的SynchronousQueue 使用队列来实现的，其内部没有使用传统的锁来控制，而是通过CAS来完成，因此需要反复检查状态是否有效，SynchronousQueue 将相同的操作（这个操作可以是put也可以是take）入队，不同的操作（put 对应take,take 对应put）那么就是互相匹配的操作，当请求的操作和队尾的操作相同时入队，否则进行出队匹配，如果有超时设置，那么就进行超时操作，入队后的线程被阻塞，直到匹配的操作到来，如果有取消操作需要被清除，如果该操作节点不是尾节点，那么执行删除操作，否则用cleanMe标记其父节点，在下一轮的clean过程中再根据情况进行删除。 </p>
<h4 id="非公平模式-TransferStack"><a href="#非公平模式-TransferStack" class="headerlink" title="非公平模式 TransferStack"></a>非公平模式 TransferStack</h4><h5 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferStack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Transferer</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 表示消费数据的消费者</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST    = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 表示生产数据的生产者</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATA       = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//表示该操作节点处于真正匹配状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FULFILLING = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 栈头结点</span></span><br><span class="line">    <span class="keyword">volatile</span> SNode head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部节点</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SNode</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 下一个结点</span></span><br><span class="line">            <span class="keyword">volatile</span> SNode next;        <span class="comment">// next node in stack</span></span><br><span class="line">            <span class="comment">// 相匹配的结点</span></span><br><span class="line">            <span class="keyword">volatile</span> SNode match;       <span class="comment">// the node matched to this</span></span><br><span class="line">            <span class="comment">// 等待的线程</span></span><br><span class="line">            <span class="keyword">volatile</span> Thread waiter;     <span class="comment">// to control park/unpark</span></span><br><span class="line">            <span class="comment">// 元素项</span></span><br><span class="line">            Object item;                <span class="comment">// data; or null for REQUESTs</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 模式。有四种可能。</span></span><br><span class="line"><span class="comment">             *  1) REQUEST 0000</span></span><br><span class="line"><span class="comment">             *  2) DATA    0001</span></span><br><span class="line"><span class="comment">             *  3) REQUEST（0000）| FULFILLING（0010） =  0010 表示消费者匹配到了生成者。REQUEST为此次操作，即出队</span></span><br><span class="line"><span class="comment">             *  4）DATA（0001）| FULFILLING（0010） =  0011 表示生成者匹配到了消费者。DATA为此次操作，即入队</span></span><br><span class="line"><span class="comment">             *  后两种是在成功匹配后，将节点入队时设置的节点模式。通过：FULFILLING|mode 计算节点模式</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">int</span> mode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransferStack中定义了三个状态：REQUEST表示消费者，DATA表示生产者，FULFILLING，表示操作匹配状态。同时还包含一个head域，表示栈顶。</p>
<h6 id="transfer源码-1"><a href="#transfer源码-1" class="headerlink" title="transfer源码"></a>transfer源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">transfer</span><span class="params">(E e, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Basic algorithm is to loop trying one of three actions:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. If apparently empty or already containing nodes of same</span></span><br><span class="line"><span class="comment"> *    mode, try to push node on stack and wait for a match,</span></span><br><span class="line"><span class="comment"> *    returning it, or null if cancelled.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. If apparently containing node of complementary mode,</span></span><br><span class="line"><span class="comment"> *    try to push a fulfilling node on to stack, match</span></span><br><span class="line"><span class="comment"> *    with corresponding waiting node, pop both from</span></span><br><span class="line"><span class="comment"> *    stack, and return matched item. The matching or</span></span><br><span class="line"><span class="comment"> *    unlinking might not actually be necessary because of</span></span><br><span class="line"><span class="comment"> *    other threads performing action 3:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 3. If top of stack already holds another fulfilling node,</span></span><br><span class="line"><span class="comment"> *    help it out by doing its match and/or pop</span></span><br><span class="line"><span class="comment"> *    operations, and then continue. The code for helping</span></span><br><span class="line"><span class="comment"> *    is essentially the same as for fulfilling, except</span></span><br><span class="line"><span class="comment"> *    that it doesn't return the item.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">SNode s = <span class="keyword">null</span>; <span class="comment">// constructed/reused as needed</span></span><br><span class="line"><span class="comment">// 根据e确定此次转移的模式（是put or take）</span></span><br><span class="line"><span class="keyword">int</span> mode = (e == <span class="keyword">null</span>) ? REQUEST : DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;  <span class="comment">//无限循环</span></span><br><span class="line">    SNode h = head; <span class="comment">//保存头结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//相同的操作模式</span></span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span> || h.mode == mode) &#123;  <span class="comment">// 头结点为null或者头结点的模式与此次转移的模式相同 empty or same-mode</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>) &#123;      <span class="comment">// 设置了timed并且等待时间小于等于0，表示不能等待，需要立即操作 can't wait</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.isCancelled())   <span class="comment">// 头结点不为null并且头结点被取消</span></span><br><span class="line">                casHead(h, h.next);     <span class="comment">// 重新设置头结点（弹出之前的头结点） pop cancelled node</span></span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 头结点为null或者头结点没有被取消</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s = snode(s, e, h, mode))) &#123;  <span class="comment">// 生成一个SNode结点；将原来的head头结点设置为该结点的next结点；将head头结点设置为该结点。入队</span></span><br><span class="line">            <span class="comment">//等待匹配操作</span></span><br><span class="line">            SNode m = awaitFulfill(s, timed, nanos);    <span class="comment">// 空旋或者阻塞直到s结点被FulFill操作所匹配</span></span><br><span class="line">            <span class="keyword">if</span> (m == s) &#123;               <span class="comment">// 匹配的结点为s结点（s结点被取消） wait was cancelled</span></span><br><span class="line">                clean(s);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//s 还没有离开栈，帮助其离开</span></span><br><span class="line">            <span class="keyword">if</span> ((h = head) != <span class="keyword">null</span> &amp;&amp; h.next == s)  <span class="comment">// h重新赋值为head头结点，并且不为null；头结点的next域为s结点，表示有结点插入到s结点之前，完成了匹配</span></span><br><span class="line">                casHead(h, s.next);     <span class="comment">// 比较并替换head域（移除插入在s之前的结点和s结点） // help s's fulfiller</span></span><br><span class="line">            <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);    <span class="comment">// 根据此次转移的类型返回元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isFulfilling(h.mode)) &#123; <span class="comment">// 不同的模式，并且没有处于正在匹配状态，则进行匹配 // try to fulfill</span></span><br><span class="line">        <span class="comment">//节点取消，更新head</span></span><br><span class="line">        <span class="keyword">if</span> (h.isCancelled())            <span class="comment">// already cancelled</span></span><br><span class="line">            <span class="comment">// 比较并替换head域（弹出头结点）</span></span><br><span class="line">            casHead(h, h.next);         <span class="comment">// pop and retry</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123;   <span class="comment">//入队一个新节点，并且处于匹配状态（表示h正在匹配）</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123; <span class="comment">// loop until matched or waiters disappear</span></span><br><span class="line">                <span class="comment">// s.next 是真正的操作节点</span></span><br><span class="line">                SNode m = s.next;       <span class="comment">// m is s's match</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// next域为null</span></span><br><span class="line">                <span class="keyword">if</span> (m == <span class="keyword">null</span>) &#123;        <span class="comment">// all waiters are gone</span></span><br><span class="line">                    <span class="comment">// 比较并替换head域</span></span><br><span class="line">                    casHead(s, <span class="keyword">null</span>);   <span class="comment">// pop fulfill node</span></span><br><span class="line">                    s = <span class="keyword">null</span>;           <span class="comment">// use new node next time</span></span><br><span class="line">                    <span class="keyword">break</span>;              <span class="comment">// restart main loop</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// m结点的next域</span></span><br><span class="line">                SNode mn = m.next;</span><br><span class="line">                <span class="keyword">if</span> (m.tryMatch(s)) &#123;    <span class="comment">// 尝试匹配，并且成功</span></span><br><span class="line">                    <span class="comment">// 比较并替换head域（弹出s结点和m结点）</span></span><br><span class="line">                    casHead(s, mn);     <span class="comment">// pop both s and m</span></span><br><span class="line">                    <span class="keyword">return</span> (E) ((mode == REQUEST) ? m.item : s.item);   <span class="comment">// 根据此次转移的类型返回元素</span></span><br><span class="line">                &#125; <span class="keyword">else</span>                  <span class="comment">// lost match</span></span><br><span class="line">                    <span class="comment">// 没有匹配成功，说明有其他线程已经匹配了，把m移出</span></span><br><span class="line">                    s.casNext(m, mn);   <span class="comment">// help unlink</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;         <span class="comment">// 头结点是真正匹配的状态，那么就帮助它匹配                  // help a fulfiller</span></span><br><span class="line">        <span class="comment">// 保存头结点的next域</span></span><br><span class="line">        SNode m = h.next;               <span class="comment">// m is h's match</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="keyword">null</span>)                  <span class="comment">// waiter is gone</span></span><br><span class="line">            <span class="comment">// 比较并替换head域（m被其他结点匹配了，需要弹出h）</span></span><br><span class="line">            casHead(h, <span class="keyword">null</span>);           <span class="comment">// pop fulfilling node</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取m结点的next域</span></span><br><span class="line">            SNode mn = m.next;</span><br><span class="line">            <span class="keyword">if</span> (m.tryMatch(h))  <span class="comment">// 帮助匹配 / help match</span></span><br><span class="line">                <span class="comment">// 比较并替换head域（弹出h和m结点）</span></span><br><span class="line">                casHead(h, mn);         <span class="comment">// pop both h and m</span></span><br><span class="line">            <span class="keyword">else</span>    <span class="comment">// 匹配不成功                     // lost match</span></span><br><span class="line">                <span class="comment">// 比较并替换next域（移除m结点）</span></span><br><span class="line">                h.casNext(m, mn);       <span class="comment">// help unlink</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大体逻辑：</p>
<ol>
<li>如果当前栈为空或者获取节点模式与栈顶模式一样，则尝试将节点加入栈内，同时通过阻塞（或自旋一段时间，如果有超时设置，则进行超时等待）等待节点匹配，最后返回匹配的节点或者本身（被取消） </li>
<li>如果栈不为空且节点的模式与首节点模式匹配，则尝试将该节点打上FULFILLING标记，然后加入栈中，与相应的节点匹配，成功后将这两个节点弹出栈并返回匹配节点的数据 </li>
<li>如果有节点在匹配，那么帮助这个节点完成匹配和出栈操作，然后在主循环中继续执行。</li>
</ol>
<h4 id="awaitFulfill源码-1"><a href="#awaitFulfill源码-1" class="headerlink" title="awaitFulfill源码"></a>awaitFulfill源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SNode <span class="title">awaitFulfill</span><span class="params">(SNode s, <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * When a node/thread is about to block, it sets its waiter</span></span><br><span class="line"><span class="comment">     * field and then rechecks state at least one more time</span></span><br><span class="line"><span class="comment">     * before actually parking, thus covering race vs</span></span><br><span class="line"><span class="comment">     * fulfiller noticing that waiter is non-null so should be</span></span><br><span class="line"><span class="comment">     * woken.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * When invoked by nodes that appear at the point of call</span></span><br><span class="line"><span class="comment">     * to be at the head of the stack, calls to park are</span></span><br><span class="line"><span class="comment">     * preceded by spins to avoid blocking when producers and</span></span><br><span class="line"><span class="comment">     * consumers are arriving very close in time.  This can</span></span><br><span class="line"><span class="comment">     * happen enough to bother only on multiprocessors.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The order of checks for returning out of main loop</span></span><br><span class="line"><span class="comment">     * reflects fact that interrupts have precedence over</span></span><br><span class="line"><span class="comment">     * normal returns, which have precedence over</span></span><br><span class="line"><span class="comment">     * timeouts. (So, on timeout, one last check for match is</span></span><br><span class="line"><span class="comment">     * done before giving up.) Except that calls from untimed</span></span><br><span class="line"><span class="comment">     * SynchronousQueue.&#123;poll/offer&#125; don't check interrupts</span></span><br><span class="line"><span class="comment">     * and don't wait at all, so are trapped in transfer</span></span><br><span class="line"><span class="comment">     * method rather than calling awaitFulfill.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 根据timed标识计算截止时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 获取当前线程</span></span><br><span class="line">    Thread w = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 根据s确定空旋等待的时间</span></span><br><span class="line">    <span class="keyword">int</span> spins = (shouldSpin(s) ?</span><br><span class="line">                 (timed ? maxTimedSpins : maxUntimedSpins) : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 无限循环，确保操作成功</span></span><br><span class="line">        <span class="keyword">if</span> (w.isInterrupted())  <span class="comment">// 当前线程被中断</span></span><br><span class="line">            <span class="comment">// 取消s结点，原理是将节点s的match域设置为this</span></span><br><span class="line">            s.tryCancel();</span><br><span class="line">        <span class="comment">// 获取s结点的match域</span></span><br><span class="line">        SNode m = s.match;</span><br><span class="line">        <span class="keyword">if</span> (m != <span class="keyword">null</span>)   <span class="comment">// m不为null，存在匹配结点</span></span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="comment">// 确定继续等待的时间</span></span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;  <span class="comment">// 继续等待的时间小于等于0，等待超时</span></span><br><span class="line">                s.tryCancel();   <span class="comment">// 取消s结点</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (spins &gt; <span class="number">0</span>)  <span class="comment">// 空旋等待的时间大于0</span></span><br><span class="line">            spins = shouldSpin(s) ? (spins-<span class="number">1</span>) : <span class="number">0</span>;   <span class="comment">// 确定是否还需要继续空旋等待</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s.waiter == <span class="keyword">null</span>)   <span class="comment">// 等待线程为null</span></span><br><span class="line">            <span class="comment">// 设置waiter线程为当前线程</span></span><br><span class="line">            s.waiter = w; <span class="comment">// establish waiter so can park next iter</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!timed)</span><br><span class="line">            <span class="comment">// 禁用当前线程并设置了阻塞者</span></span><br><span class="line">            LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; spinForTimeoutThreshold)   <span class="comment">// 继续等待的时间大于阈值</span></span><br><span class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos); <span class="comment">// 禁用当前线程，最多等待指定的等待时间，除非许可可用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整体逻辑：</p>
<ol>
<li>获取超时截止时间，当前线程及空旋等待时间</li>
<li>进入无限循环 <ol>
<li>判断当前线程是否被中断。是，将节点s取消，即将节点s的 <code>match域设置为this</code>；否，进入下一步。</li>
<li>获取节点s的match域值m。如果m不为空，则说明节点s已被匹配，直接返回m；否则，进行下一步。</li>
<li>如果设置了超时时间，则判断是否超时。超时，则将节点s取消，<code>continue</code>继续循环。</li>
<li>如果没有设置超时，则空旋一段时间，最后将当前线程阻塞。</li>
</ol>
</li>
</ol>
<h4 id="clean源码-1"><a href="#clean源码-1" class="headerlink" title="clean源码"></a>clean源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除从栈顶头结点开始到该结点（不包括）之间的所有已取消结点。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clean</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// s结点的item设置为null</span></span><br><span class="line">    s.item = <span class="keyword">null</span>;   <span class="comment">// forget item</span></span><br><span class="line">    <span class="comment">// s结点的waiter设置为null</span></span><br><span class="line">    s.waiter = <span class="keyword">null</span>; <span class="comment">// forget thread</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * At worst we may need to traverse entire stack to unlink</span></span><br><span class="line"><span class="comment">     * s. If there are multiple concurrent calls to clean, we</span></span><br><span class="line"><span class="comment">     * might not see s if another thread has already removed</span></span><br><span class="line"><span class="comment">     * it. But we can stop when we see any node known to</span></span><br><span class="line"><span class="comment">     * follow s. We use s.next unless it too is cancelled, in</span></span><br><span class="line"><span class="comment">     * which case we try the node one past. We don't check any</span></span><br><span class="line"><span class="comment">     * further because we don't want to doubly traverse just to</span></span><br><span class="line"><span class="comment">     * find sentinel.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//被删除节点的后继</span></span><br><span class="line">    SNode past = s.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后继节点操作被取消，直接移除该节点</span></span><br><span class="line">    <span class="keyword">if</span> (past != <span class="keyword">null</span> &amp;&amp; past.isCancelled()) <span class="comment">// next域不为null并且next域被取消</span></span><br><span class="line">        past = past.next;   <span class="comment">// 重新设置past</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Absorb cancelled nodes at head</span></span><br><span class="line">    SNode p;</span><br><span class="line">    <span class="comment">//如果栈顶是取消了的操作节点，则移除</span></span><br><span class="line">    <span class="keyword">while</span> ((p = head) != <span class="keyword">null</span> &amp;&amp; p != past &amp;&amp; p.isCancelled())   <span class="comment">// 从栈顶头结点开始到past结点（不包括），将连续的取消结点移除</span></span><br><span class="line">        casHead(p, p.next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unsplice embedded nodes</span></span><br><span class="line">    <span class="comment">//因为是单向链表，因此需要从head 开始，遍历到被删除节点的后继</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p != past) &#123;     <span class="comment">// 移除上一步骤没有移除的非连续的取消结点</span></span><br><span class="line">        SNode n = p.next;   <span class="comment">// 获取p的next域</span></span><br><span class="line">        <span class="keyword">if</span> (n != <span class="keyword">null</span> &amp;&amp; n.isCancelled())   <span class="comment">// n不为null并且n被取消</span></span><br><span class="line">            p.casNext(n, n.next);    <span class="comment">// 比较并替换next域</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要功能：从栈顶删除节点s。大体逻辑：</p>
<ol>
<li>将待删除节点s的item域，waiter域都设置为null</li>
<li>获取待删除节点s的next域节点past</li>
<li>如果节点past不为null且节点past已被取消，则先删除其后继节点</li>
<li>如果head操作节点也被取消，那么就重新更新头节点</li>
<li>因为是单链表，因此需要遍历链表，从head 到s的后继中，有被取消了的操作的节点，那么就移除掉。 </li>
</ol>
<h4 id="isFulfilling源码"><a href="#isFulfilling源码" class="headerlink" title="isFulfilling源码"></a>isFulfilling源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//是否处于匹配状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isFulfilling</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (m &amp; FULFILLING) != <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="tryMatch源码"><a href="#tryMatch源码" class="headerlink" title="tryMatch源码"></a>tryMatch源码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryMatch</span><span class="params">(SNode s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (match == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, matchOffset, <span class="keyword">null</span>, s)) &#123;</span><br><span class="line">        Thread w = waiter;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>) &#123;    <span class="comment">// waiters need at most one unpark</span></span><br><span class="line">            waiter = <span class="keyword">null</span>;</span><br><span class="line">            LockSupport.unpark(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> match == s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>match</code>不为空，则说明当前操作已经被匹配或者取消了，则直接判断 <code>match == s</code> 是否为true；否则CAS将当前节点的<code>match</code>值设置为节点s，如果成功，则通过<code>LockSupport.unpark(w);</code> 唤起线程。</p>
<h4 id="TransferStack-总结"><a href="#TransferStack-总结" class="headerlink" title="TransferStack 总结"></a>TransferStack 总结</h4><p>将一个操作和栈顶进行匹配，如果和栈顶是相同的操作，那么就直接入栈，如果和栈顶不是相同的操作（也就是匹配的操作，take匹配put,put匹配take）,那么现在先不急出栈，因为此时可能有线程真正入栈，为了避免出现操作错误，这里加了一个环节，如果操作是匹配的(即需要出栈)，那么入栈一个节点，并标记是真正匹配状态，表示的是栈顶操作节点真正匹配，如果其他线程发现这个过程，那么就会帮助其匹配（使其顺序完成出栈工作），完成匹配过后，再进行自身的操作. </p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="http://blog.csdn.net/u014634338/article/details/78419445" target="_blank" rel="noopener">Java 并发 — 阻塞队列之SynchronousQueue源码分析(真心不错)</a></p>
<p><a href="http://www.jianshu.com/p/9d2c706e45b7?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之阻塞队列：SynchronousQueue</a></p>
<p><a href="http://www.jianshu.com/p/95cb570c8187" target="_blank" rel="noopener">SynchronousQueue 源码分析 (基于Java 8)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://houlong123.github.io/2017/12/12/SynchronousQueue源码解析/" data-id="cjg3u3jxs002fth0mi4sjkn7y" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java并发集合/">java并发集合</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/21/Fork-Join框架源码学习之ForkJoinTask学习/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Fork/Join框架源码学习之ForkJoinTask学习
        
      </div>
    </a>
  
  
    <a href="/2017/11/30/DelayQueue源码学习/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">DelayQueue源码学习</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dokuwiki部署/">dokuwiki部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java基础集合/">java基础集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发/">java并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发锁/">java并发锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发集合/">java并发集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/部署GitHub-Page/">部署GitHub Page</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mysql/" style="font-size: 11.43px;">Mysql</a> <a href="/tags/Spring/" style="font-size: 14.29px;">Spring</a> <a href="/tags/dokuwiki部署/" style="font-size: 10px;">dokuwiki部署</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/java基础集合/" style="font-size: 18.57px;">java基础集合</a> <a href="/tags/java并发/" style="font-size: 12.86px;">java并发</a> <a href="/tags/java并发锁/" style="font-size: 15.71px;">java并发锁</a> <a href="/tags/java并发集合/" style="font-size: 17.14px;">java并发集合</a> <a href="/tags/部署GitHub-Page/" style="font-size: 10px;">部署GitHub Page</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/02/类初始化顺序/">类初始化顺序</a>
          </li>
        
          <li>
            <a href="/2018/04/01/JVM额外知识学习/">JVM额外知识学习</a>
          </li>
        
          <li>
            <a href="/2018/03/20/Integer类学习/">Integer类学习</a>
          </li>
        
          <li>
            <a href="/2018/03/18/JVM-学习/">JVM 学习</a>
          </li>
        
          <li>
            <a href="/2018/02/26/TreeMap源码学习/">TreeMap源码学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 houlong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
  <a href="https://github.com/houlong123"><img style="position: absolute; top: 0; right: 0; border: 0; z-index: 1000;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
</body>
</html>
