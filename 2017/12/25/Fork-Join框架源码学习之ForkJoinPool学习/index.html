<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Fork/Join框架源码学习之ForkJoinPool学习 | 而今伊始，命途自闯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 Fork/Join框架源码学习之ForkJoinTask学习 文章中，我们已经初步分析了Fork/Join框架中的一个重要类 ForkJoinTask类。在本篇文章中，我们分析一下Fork/Join框架中的另一个重要类：ForkJoinPool。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在ForkJoinPool的介绍中有说：Fork">
<meta name="keywords" content="java并发">
<meta property="og:type" content="article">
<meta property="og:title" content="Fork&#x2F;Join框架源码学习之ForkJoinPool学习">
<meta property="og:url" content="https://houlong123.github.io/2017/12/25/Fork-Join框架源码学习之ForkJoinPool学习/index.html">
<meta property="og:site_name" content="而今伊始，命途自闯">
<meta property="og:description" content="前言&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 Fork/Join框架源码学习之ForkJoinTask学习 文章中，我们已经初步分析了Fork/Join框架中的一个重要类 ForkJoinTask类。在本篇文章中，我们分析一下Fork/Join框架中的另一个重要类：ForkJoinPool。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在ForkJoinPool的介绍中有说：Fork">
<meta property="og:updated_time" content="2018-01-25T07:16:55.891Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fork&#x2F;Join框架源码学习之ForkJoinPool学习">
<meta name="twitter:description" content="前言&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在 Fork/Join框架源码学习之ForkJoinTask学习 文章中，我们已经初步分析了Fork/Join框架中的一个重要类 ForkJoinTask类。在本篇文章中，我们分析一下Fork/Join框架中的另一个重要类：ForkJoinPool。 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在ForkJoinPool的介绍中有说：Fork">
  
    <link rel="alternate" href="/atom.xml" title="而今伊始，命途自闯" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">而今伊始，命途自闯</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://houlong123.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Fork-Join框架源码学习之ForkJoinPool学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/25/Fork-Join框架源码学习之ForkJoinPool学习/" class="article-date">
  <time datetime="2017-12-25T07:14:29.000Z" itemprop="datePublished">2017-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Fork/Join框架源码学习之ForkJoinPool学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;在 <a href="https://houlong123.github.io/2017/12/21/Fork-Join框架源码学习之ForkJoinTask学习/">Fork/Join框架源码学习之ForkJoinTask学习</a> 文章中，我们已经初步分析了Fork/Join框架中的一个重要类 <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinTask.html" target="_blank" rel="noopener">ForkJoinTask类</a>。在本篇文章中，我们分析一下Fork/Join框架中的另一个重要类：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ForkJoinPool.html" target="_blank" rel="noopener">ForkJoinPool</a>。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在<code>ForkJoinPool</code>的介绍中有说：<code>ForkJoinPool是一种用于运行ForkJoinTasks的ExecutorService</code>（An ExecutorService for running ForkJoinTasks）。即<code>ForkJoinPool</code>也是一种<code>ExecutorService</code>。但由于<font color="red">工作窃取(work-stealing)</font>的缘故，该类与其他<code>ExecutorService</code>又不太一样。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;创建<code>ForkJoinPool</code>对象的方式有多种，在后面的分析中，可以看到该类有多个重载的构造函数。但是在官方文档中，比较推荐使用静态方法 <code>commonPool()</code> 创建<code>ForkJoinPool</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">官方文档描述：</span><br><span class="line"></span><br><span class="line">A static commonPool() is available and appropriate for most applications. </span><br><span class="line">The common pool is used by any ForkJoinTask that is not explicitly </span><br><span class="line">submitted to a specified pool. Using the common pool normally reduces resource </span><br><span class="line">usage (its threads are slowly reclaimed during periods of non-use, and reinstated upon subsequent use).</span><br></pre></td></tr></table></figure>
<h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><a id="more"></a>
<h5 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinPool</span> <span class="keyword">extends</span> <span class="title">AbstractExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> ctl;                   <span class="comment">// main pool control</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线程池运行状态。对应状态为下面各值。在为SHUTDOWN时，其值为负数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> runState;               <span class="comment">// lockable status</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// runState bits: SHUTDOWN must be negative, others arbitrary powers of two</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RSLOCK     = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  RSIGNAL    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  STARTED    = <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  STOP       = <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  TERMINATED = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>  SHUTDOWN   = <span class="number">1</span> &lt;&lt; <span class="number">31</span>; <span class="comment">//负数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认工作线程工厂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ForkJoinWorkerThreadFactory</span><br><span class="line">            defaultForkJoinWorkerThreadFactory;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//静态方法commonPool()会初始化该值      </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ForkJoinPool common;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">volatile</span> WorkQueue[] workQueues;     <span class="comment">// main registry</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinWorkerThreadFactory factory;</span><br><span class="line">    <span class="keyword">final</span> UncaughtExceptionHandler ueh;  <span class="comment">// per-worker UEH</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部工作队列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkQueue</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//工作队列线程创建工厂类，该类用于创建工作线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">interface</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Returns a new worker thread operating in the given pool.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> pool the pool this thread works in</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> the new worker thread</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> NullPointerException if the pool is null</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default ForkJoinWorkerThreadFactory implementation; creates a</span></span><br><span class="line"><span class="comment">     * new ForkJoinWorkerThread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//默认生产工作线程的工厂。在构造ForkJoinPool对象时，默认使用该工厂类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultForkJoinWorkerThreadFactory</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">ForkJoinWorkerThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinWorkerThread <span class="title">newThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinWorkerThread(pool);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 ForkJoinPool 类的内部数据结构可知，该类最重要的属性有两个：<code>WorkQueue[] workQueues</code> 和 <code>ForkJoinWorkerThreadFactory factory</code>。这两个类中，一个是工作队列列表，因为池中会有多个工作队列；另一个是用于创建工作线程的工厂。在工作线程类<code>ForkJoinWorkerThread</code>中，我们可知该类中封装了一个工作队列和线程池。</p>
<h5 id="ForkJoinWorkerThread-数据结构"><a href="#ForkJoinWorkerThread-数据结构" class="headerlink" title="ForkJoinWorkerThread 数据结构"></a>ForkJoinWorkerThread 数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinWorkerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ForkJoinWorkerThreads are managed by ForkJoinPools and perform</span></span><br><span class="line"><span class="comment">     * ForkJoinTasks. For explanation, see the internal documentation</span></span><br><span class="line"><span class="comment">     * of class ForkJoinPool.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This class just maintains links to its pool and WorkQueue.  The</span></span><br><span class="line"><span class="comment">     * pool field is set immediately upon construction, but the</span></span><br><span class="line"><span class="comment">     * workQueue field is not set until a call to registerWorker</span></span><br><span class="line"><span class="comment">     * completes. This leads to a visibility race, that is tolerated</span></span><br><span class="line"><span class="comment">     * by requiring that the workQueue field is only accessed by the</span></span><br><span class="line"><span class="comment">     * owning thread.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Support for (non-public) subclass InnocuousForkJoinWorkerThread</span></span><br><span class="line"><span class="comment">     * requires that we break quite a lot of encapsulation (via Unsafe)</span></span><br><span class="line"><span class="comment">     * both here and in the subclass to access and set Thread fields.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool pool;                <span class="comment">// the pool this thread works in</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool.WorkQueue workQueue; <span class="comment">// work-stealing mechanics</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由<code>ForkJoinWorkerThread</code>的源码可知，该类继续了<code>Thread</code>类，并且内部维持一个<code>ForkJoinPool</code>和<code>WorkQueue</code>对象。由文档注释可知：ForkJoinWorkerThread 由ForkJoinPool管理并执行ForkJoinTask。</p>
<h5 id="ForkJoinWorkerThread内部主要方法"><a href="#ForkJoinWorkerThread内部主要方法" class="headerlink" title="ForkJoinWorkerThread内部主要方法"></a>ForkJoinWorkerThread内部主要方法</h5><h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Use a placeholder until a useful name can be set in registerWorker</span></span><br><span class="line">    <span class="keyword">super</span>(<span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ForkJoinWorkerThread(ForkJoinPool pool, ThreadGroup threadGroup,</span><br><span class="line">                     AccessControlContext acc) &#123;</span><br><span class="line">    <span class="keyword">super</span>(threadGroup, <span class="keyword">null</span>, <span class="string">"aForkJoinWorkerThread"</span>);</span><br><span class="line">    U.putOrderedObject(<span class="keyword">this</span>, INHERITEDACCESSCONTROLCONTEXT, acc);</span><br><span class="line">    eraseThreadLocals(); <span class="comment">// clear before registering</span></span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = pool.registerWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造函数中，使用是初始化了<code>ForkJoinPool</code>和<code>WorkQueue</code>对象。在初始化 WorkQueue 对象时，调用了 ForkJoinPool 类中的 <code>registerWorker()</code>方法。该方法在下文分析。 </p>
<h6 id="run源码"><a href="#run源码" class="headerlink" title="run源码"></a>run源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载Thread中的run，执行ForkJoinTask任务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//仅在工作队列中的任务列表为空时，才会执行run方法中的实现逻辑</span></span><br><span class="line">    <span class="keyword">if</span> (workQueue.array == <span class="keyword">null</span>) &#123; <span class="comment">// only run once</span></span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onStart();</span><br><span class="line">            <span class="comment">//调用pool的runWorker来获取任务执行</span></span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                onTermination(exception);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>)</span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                pool.deregisterWorker(<span class="keyword">this</span>, exception);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在使用多线程的时候，已经了解过，要新建一个线程，需要继承<code>Thread</code>类，然后实现<code>run()</code>方法。在线程启动后，会调用相应的<code>run()</code>方法。在<code>ForkJoinWorkerThread</code>类的<code>run()</code>方法实现中， 调用了ForkJoinPool 类中的 <code>runWorker()</code>方法。该方法在下文分析。 </p>
<h5 id="WorkerQueue数据结构"><a href="#WorkerQueue数据结构" class="headerlink" title="WorkerQueue数据结构"></a>WorkerQueue数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内部工作队列</span></span><br><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_QUEUE_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M</span></span><br><span class="line">    <span class="comment">// Instance fields</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> scanState;    <span class="comment">// versioned, &lt;0: inactive; odd:scanning</span></span><br><span class="line">    <span class="keyword">int</span> stackPred;             <span class="comment">// pool stack (ctl) predecessor</span></span><br><span class="line">    <span class="keyword">int</span> nsteals;               <span class="comment">// number of steals</span></span><br><span class="line">    <span class="keyword">int</span> hint;                  <span class="comment">// randomization and stealer index hint</span></span><br><span class="line">    <span class="keyword">int</span> config;                <span class="comment">// pool index and mode</span></span><br><span class="line">    <span class="comment">// 队列状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line">    <span class="comment">// 下一个出队元素的索引位</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> base;         <span class="comment">// index of next slot for poll</span></span><br><span class="line">    <span class="comment">// 为下一个入队元素准备的索引位</span></span><br><span class="line">    <span class="keyword">int</span> top;                   <span class="comment">// index of next slot for push</span></span><br><span class="line">    <span class="comment">// 队列中使用数组存储元素</span></span><br><span class="line">    ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// the elements (initially unallocated)</span></span><br><span class="line">    <span class="comment">// 队列所属的ForkJoinPool（可能为空）</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line">    <span class="comment">// 这个队列所属的归并计算工作线程。注意，工作队列也可能不属于任何工作线程</span></span><br><span class="line">    <span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// owning thread or null if shared</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread parker;    <span class="comment">// == owner during call to park; else null</span></span><br><span class="line">    <span class="comment">// 记录当前正在进行join等待的其它任务</span></span><br><span class="line">    <span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// task being joined in awaitJoin</span></span><br><span class="line">    <span class="comment">// 当前正在偷取的任务</span></span><br><span class="line">    <span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// mainly used by helpStealer</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在内部类<code>WorkQueue</code>的数据结构中，可以看到，该类内部有个数组类型的ForkJoinTask对象，用于存放待执行任务。<code>ForkJoinPool</code>类型的对象用于记录该队列所属的 ForkJoinPool。</p>
<h5 id="WorkQueue内部主要方法"><a href="#WorkQueue内部主要方法" class="headerlink" title="WorkQueue内部主要方法"></a>WorkQueue内部主要方法</h5><h6 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">WorkQueue(ForkJoinPool pool, ForkJoinWorkerThread owner) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pool = pool;</span><br><span class="line">    <span class="keyword">this</span>.owner = owner;</span><br><span class="line">    <span class="comment">// Place indices in the center of array (that is not yet allocated)</span></span><br><span class="line">    base = top = INITIAL_QUEUE_CAPACITY &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在下文分析中可知，在将任务插入相应工作队列后，如果队列为空，则会调用该方法进行队列初始化。</p>
<h6 id="push源码"><a href="#push源码" class="headerlink" title="push源码"></a>push源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pushes a task. Call only by owner in unshared queues.  (The</span></span><br><span class="line"><span class="comment"> * shared-queue version is embedded in method externalPush.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task. Caller must ensure non-null.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException if array cannot be resized</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//添加任务。 只有拥有者在非共享队列中才能调用</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; ForkJoinPool p;</span><br><span class="line">    <span class="keyword">int</span> b = base, s = top, n;</span><br><span class="line">    <span class="comment">// 请注意，在执行task.fork时，触发push情况下，array不会为null</span></span><br><span class="line">    <span class="comment">// 因为在这之前workqueue中的array已经完成了初始化（在工作线程初始化时就完成了）</span></span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="keyword">int</span> m = a.length - <span class="number">1</span>;     <span class="comment">// fenced write for task visibility</span></span><br><span class="line">        <span class="comment">// putOrderedObject方法在指定的对象a中，指定的内存偏移量的位置，赋予一个新的元素</span></span><br><span class="line">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">        <span class="comment">// putOrderedInt方法对当前指定的对象中的指定字段，进行赋值操作</span></span><br><span class="line">        <span class="comment">// 这里的代码意义是将workQueue对象本身中的top标示的位置 + 1，</span></span><br><span class="line">        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = pool) != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">// signalWork方法的意义在于，在当前活动的工作线程过少的情况下，创建新的工作线程</span></span><br><span class="line">                p.signalWork(p.workQueues, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)    <span class="comment">// 如果array的剩余空间不够了，则进行增加</span></span><br><span class="line">            growArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在分析 <a href="https://houlong123.github.io/2017/12/21/Fork-Join框架源码学习之ForkJoinTask学习/">ForkJoinTask</a> 的<code>fork</code>源码时，我们已经知道：如果添加任务的线程为工作线程，则会调用该方法将任务入队。该方法的大致逻辑为：</p>
<ol>
<li>判断工作队列内部任务列表是否为空，如果非空，往下执行；否则方法结束。</li>
<li>定位待插入元素的索引：<code>(m &amp; s) &lt;&lt; ASHIFT) + ABASE</code></li>
<li>将元素入队</li>
<li>当前活动的工作线程过少的情况下，则调用<code>signalWork()</code>方法创建或激活工作线程。</li>
<li>如果需要扩容，则进行扩容操作</li>
</ol>
<h6 id="pop源码"><a href="#pop源码" class="headerlink" title="pop源码"></a>pop源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Takes next task, if one exists, in LIFO order.  Call only</span></span><br><span class="line"><span class="comment"> * by owner in unshared queues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//通过LIFO策略（后进先出队列），获取下一个任务</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; pop() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;   <span class="comment">//在待工作任务不为空，且数量大于1的时候，从待工作列表中获取下一个任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s; (s = top - <span class="number">1</span>) - base &gt;= <span class="number">0</span>;) &#123; <span class="comment">//将top值减一，赋值给变量s，如果s&gt;=base,则遍历数组，获取下个任务的索引</span></span><br><span class="line">            <span class="keyword">long</span> j = ((m &amp; s) &lt;&lt; ASHIFT) + ABASE;   <span class="comment">//定位下个任务的索引</span></span><br><span class="line">            <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == <span class="keyword">null</span>)   <span class="comment">//从工作列表中获取指定索引处的值，如果为空，break。跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;    <span class="comment">//将原来索引处的值置为null，并重新设置top值</span></span><br><span class="line">                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的功能：以后进先出（LIFO）策略，获取下一个待执行任务。该策略是在构造<code>ForkJoinPool</code>对象时根据<code>asyncMode</code>属性值决定：<code>策略 = asyncMode ? FIFO_QUEUE : LIFO_QUEUE</code>。</p>
<p>该方法逻辑很简单，就是从队列的头部（top位置）获取下个工作任务。</p>
<h6 id="poll源码"><a href="#poll源码" class="headerlink" title="poll源码"></a>poll源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Takes next task, if one exists, in FIFO order.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 通过FIFO策略（先进先去），获取下一个任务</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; poll() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> b; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">    <span class="keyword">while</span> ((b = base) - top &lt; <span class="number">0</span> &amp;&amp; (a = array) != <span class="keyword">null</span>) &#123;   <span class="comment">//在有待处理任务且列表不为空的情况下，循环遍历任务列表</span></span><br><span class="line">        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;    <span class="comment">//定位下个任务的索引</span></span><br><span class="line">        t = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(a, j);     <span class="comment">//获取索引处的值</span></span><br><span class="line">        <span class="keyword">if</span> (base == b) &#123;    <span class="comment">//在没有其他线程修改列表的话，往下执行</span></span><br><span class="line">            <span class="comment">//任务不为空的情况下，设置列表，并修改base值，然后返回任务</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    base = b + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (b + <span class="number">1</span> == top) <span class="comment">// now empty 如果b + 1 == top，则说明队列为空，没有可执行的任务，跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法与<code>pop()</code>方法的逻辑一致，只是该方法是从队列的尾部(base位置)获取下个待执行任务。</p>
<h6 id="nextLocalTask源码"><a href="#nextLocalTask源码" class="headerlink" title="nextLocalTask源码"></a>nextLocalTask源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Takes next task, if one exists, in order specified by mode.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//获取下一个待执行任务。取决于构建ForkJoinPool对象时设置的asyncMode。在asyncMode=true时，表明队列为FIFO队列，使用poll()获取下一任务；否则使用pop()获取下一任务。</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt; nextLocalTask() &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * LIFO_QUEUE   = 0;</span></span><br><span class="line"><span class="comment">     * FIFO_QUEUE   = 1 &lt;&lt; 16;</span></span><br><span class="line"><span class="comment">     * SMASK        = 0xffff;</span></span><br><span class="line"><span class="comment">     * mode = asyncMode ? FIFO_QUEUE : LIFO_QUEUE</span></span><br><span class="line"><span class="comment">     * config = (parallelism &amp; SMASK) | mode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (config &amp; FIFO_QUEUE) == <span class="number">0</span> ? pop() : poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会在任务添加进工作队列后，调用<code>signalWork()</code>方法添加新工作线程时被调用。具体流程在另篇文章分析。</p>
<p>该方法的功能就是根据不同顺序获取下个待执行任务。该顺序取决于构建ForkJoinPool对象时设置的asyncMode。在asyncMode=true时，表明队列为FIFO队列，使用poll()获取下一任务；否则使用pop()获取下一任务。</p>
<h6 id="tryUnpush源码"><a href="#tryUnpush源码" class="headerlink" title="tryUnpush源码"></a>tryUnpush源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pops the given task only if it is at the current top.</span></span><br><span class="line"><span class="comment"> * (A shared version is available only via FJP.tryExternalUnpush)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//当指定的任务为当前队列顶部时，弹出</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryUnpush</span><span class="params">(ForkJoinTask&lt;?&gt; t)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (s = top) != base &amp;&amp;     <span class="comment">//待处理任务列表不为空且有元素</span></span><br><span class="line">            U.compareAndSwapObject</span><br><span class="line">                    (a, (((a.length - <span class="number">1</span>) &amp; --s) &lt;&lt; ASHIFT) + ABASE, t, <span class="keyword">null</span>)) &#123;     <span class="comment">//将任务出队</span></span><br><span class="line">        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要的功能是：将任务t从工作队列中取出。从代码注释可知，该方法有一个相同逻辑的名为<code>tryExternalUnpush()</code>方法，该方法为<code>ForkJoinPool</code>中的方法。</p>
<h6 id="runTask源码"><a href="#runTask源码" class="headerlink" title="runTask源码"></a>runTask源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Executes the given task and any remaining local tasks.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="keyword">null</span>) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; <span class="comment">//标识该线程处于繁忙状态 mark as busy</span></span><br><span class="line">        (currentSteal = task).doExec(); <span class="comment">//执行偷取的Task</span></span><br><span class="line">        U.putOrderedObject(<span class="keyword">this</span>, QCURRENTSTEAL, <span class="keyword">null</span>); <span class="comment">// release for GC</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用execLocalTasks对线程所属的WorkQueue内的任务进行LIFO执行</span></span><br><span class="line">        execLocalTasks();</span><br><span class="line">        ForkJoinWorkerThread thread = owner;</span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)      <span class="comment">// collect on overflow</span></span><br><span class="line">            transferStealCount(pool);</span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            thread.afterTopLevelExec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的功能是：执行给定的任务或者窃取其他工作队列的任务并执行。</p>
<h6 id="execLocalTasks源码"><a href="#execLocalTasks源码" class="headerlink" title="execLocalTasks源码"></a>execLocalTasks源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes and executes all local tasks. If LIFO, invokes</span></span><br><span class="line"><span class="comment"> * pollAndExecAll. Otherwise implements a specialized pop loop</span></span><br><span class="line"><span class="comment"> * to exec until empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//删除并执行所有本地任务。</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">execLocalTasks</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b = base, m, s;</span><br><span class="line">    <span class="comment">//获取当前线程内部任务</span></span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b - (s = top - <span class="number">1</span>) &lt;= <span class="number">0</span> &amp;&amp; a != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;  <span class="comment">//有任务</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((config &amp; FIFO_QUEUE) == <span class="number">0</span>) &#123;   <span class="comment">//如果是先进先出（FIFO）队列，则从top位置依次取出任务并执行</span></span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getAndSetObject</span><br><span class="line">                        (a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, <span class="keyword">null</span>)) == <span class="keyword">null</span>)    <span class="comment">//任务为空，则说明还没有任务，则跳出循环，方法结束</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//修改top值</span></span><br><span class="line">                U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                <span class="comment">//执行任务</span></span><br><span class="line">                t.doExec();</span><br><span class="line">                <span class="comment">//如果任务全部执行完，则跳出循环，方法结束</span></span><br><span class="line">                <span class="keyword">if</span> (base - (s = top - <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">//如果是后进先出（LIFO）队列，则调用pollAndExecAll方法删除并执行任务</span></span><br><span class="line">            pollAndExecAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的功能是：删除并执行所有本地任务，即工作队列处理自己内部的所有任务。代码逻辑：</p>
<ol>
<li>获取当前工作队列的内部任务</li>
<li>如果内部任务不为空，则往下执行；否则，方法结束</li>
<li>如果队列为FIFO，则从top位置开始删除并执行任务</li>
<li>如果队列为LIFO，则调用<code>pollAndExecAll()</code>方法执行任务。</li>
</ol>
<h6 id="pollAndExecAll源码"><a href="#pollAndExecAll源码" class="headerlink" title="pollAndExecAll源码"></a>pollAndExecAll源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Polls and runs tasks until empty.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">pollAndExecAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; (t = poll()) != <span class="keyword">null</span>;)</span><br><span class="line">        t.doExec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，循环调用<code>poll()</code>方法从工作队列中获取任务，然后执行。</p>
<h6 id="tryRemoveAndExec源码"><a href="#tryRemoveAndExec源码" class="headerlink" title="tryRemoveAndExec源码"></a>tryRemoveAndExec源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * If present, removes from queue and executes the given task,</span></span><br><span class="line"><span class="comment"> * or any other cancelled task. Used only by awaitJoin.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if queue empty and task not known to be done</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRemoveAndExec</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> m, s, b, n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断待处理任务列表是否为空</span></span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="keyword">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            task != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历 找到task,尝试进行执行和删除操作</span></span><br><span class="line">        <span class="keyword">while</span> ((n = (s = top) - (b = base)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;      <span class="comment">// traverse from s to b</span></span><br><span class="line">                <span class="comment">//从索引s处开始遍历</span></span><br><span class="line">                <span class="keyword">long</span> j = ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;)U.getObject(a, j)) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> s + <span class="number">1</span> == top;     <span class="comment">// shorter than expected</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t == task) &#123;   <span class="comment">//找到任务</span></span><br><span class="line">                    <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//移除任务</span></span><br><span class="line">                    <span class="keyword">if</span> (s + <span class="number">1</span> == top) &#123;      <span class="comment">// pop</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, j, task, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                            U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                            removed = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (base == b)      <span class="comment">// replace with proxy</span></span><br><span class="line">                        removed = U.compareAndSwapObject(</span><br><span class="line">                                a, j, task, <span class="keyword">new</span> EmptyTask());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//如果任务被移除，执行task任务</span></span><br><span class="line">                    <span class="keyword">if</span> (removed)</span><br><span class="line">                        task.doExec();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t.status &lt; <span class="number">0</span> &amp;&amp; s + <span class="number">1</span> == top) &#123;    <span class="comment">//遍历到的任务t被取消，则移除任务t，并重新设置top值，然后重新遍历</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="keyword">null</span>))</span><br><span class="line">                        U.putOrderedInt(<span class="keyword">this</span>, QTOP, s);</span><br><span class="line">                    <span class="keyword">break</span>;                  <span class="comment">// was cancelled</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--n == <span class="number">0</span>)   <span class="comment">//没有带处理任务</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (task.status &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的功能是：执行并移除指定任务。代码逻辑：</p>
<ol>
<li>判断功能队列中的任务是否为空，为空，直接返回；否则，往下执行。</li>
<li>遍历任务列表，找到task,尝试进行执行和删除操作<ol>
<li>从top位置遍历任务列表，获取索引j.</li>
<li>如果索引j处的任务为空，则自增top值，继续遍历。</li>
<li>如果索引j处的任务为指定任务，则从任务列表中移除任务，并执行。</li>
<li>如果索引j处的任务t被取消，则移除任务t，并重新设置top值，然后重新遍历。</li>
</ol>
</li>
</ol>
<p><code>备注：WorkerQueue中的大部分方法都是在启动工作线程后，会被调用到。</code></p>
<h5 id="ForkJoinPool主要方法"><a href="#ForkJoinPool主要方法" class="headerlink" title="ForkJoinPool主要方法"></a>ForkJoinPool主要方法</h5><h6 id="构造函数-2"><a href="#构造函数-2" class="headerlink" title="构造函数"></a>构造函数</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无参构造函数。默认线程数为处理器的核数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),</span><br><span class="line">            defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定线程数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parallelism, defaultForkJoinWorkerThreadFactory, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                    ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                    UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">boolean</span> asyncMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkParallelism(parallelism),</span><br><span class="line">            checkFactory(factory),</span><br><span class="line">            handler,</span><br><span class="line">            asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">            <span class="string">"ForkJoinPool-"</span> + nextPoolId() + <span class="string">"-worker-"</span>);</span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ForkJoinPool</span><span class="params">(<span class="keyword">int</span> parallelism,</span></span></span><br><span class="line"><span class="function"><span class="params">                     ForkJoinWorkerThreadFactory factory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     UncaughtExceptionHandler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">int</span> mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                     String workerNamePrefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.workerNamePrefix = workerNamePrefix;</span><br><span class="line">    <span class="keyword">this</span>.factory = factory;</span><br><span class="line">    <span class="keyword">this</span>.ueh = handler;</span><br><span class="line">    <span class="keyword">this</span>.config = (parallelism &amp; SMASK) | mode;</span><br><span class="line">    <span class="keyword">long</span> np = (<span class="keyword">long</span>)(-parallelism); <span class="comment">// offset ctl counts</span></span><br><span class="line">    <span class="comment">//ctl初始化为一个long型负数</span></span><br><span class="line">    <span class="keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可知，ForkJoinPool 有四个构造函数，但是有一个是用<code>private</code>修饰符进行修饰的，说明它不能直接调到，其他三个间接或直接调用这个私有构造函数。在默认情况下，池中的线程数为处理器的核数，并使用默认线程创建工厂。</p>
<h6 id="submit源码"><a href="#submit源码" class="headerlink" title="submit源码"></a>submit源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Submits a ForkJoinTask for execution.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task to submit</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the task's result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the task is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> RejectedExecutionException if the task cannot be</span></span><br><span class="line"><span class="comment"> *         scheduled for execution</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//提交一个ForkJoinTask执行</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    externalPush(task);</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的功能是：<code>提交一个ForkJoinTask执行</code>。在提交任务之前，会进行非空判断。如果提交的任务为null，则抛异常；否则调用内部方法<code>externalPush()</code>进行处理。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在 ForkJoinPool 类中，有多个重载的<code>submit()</code>方法。重载的方法都会接受一个<code>Runnable</code> 或者 <code>Callable&lt;T&gt;</code> 类型的参数。在方法内部，都会将对应的参数封装成<code>ForkJoinTask</code> 类型的对象，然后同样调用内部方法<code>externalPush()</code>进行处理。</p>
<h6 id="重载submit源码"><a href="#重载submit源码" class="headerlink" title="重载submit源码"></a>重载submit源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ForkJoinTask&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    ForkJoinTask&lt;T&gt; job = <span class="keyword">new</span> ForkJoinTask.AdaptedCallable&lt;T&gt;(task);</span><br><span class="line">    externalPush(job);</span><br><span class="line">    <span class="keyword">return</span> job;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="externalPush源码"><a href="#externalPush源码" class="headerlink" title="externalPush源码"></a>externalPush源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to add the given task to a submission queue at</span></span><br><span class="line"><span class="comment"> * submitter's current queue. Only the (vastly) most common path</span></span><br><span class="line"><span class="comment"> * is directly handled in this method, while screening for need</span></span><br><span class="line"><span class="comment"> * for externalSubmit.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task. Caller must ensure non-null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//该方法是在当前线程为非工作线程插入任务时调用。如果当前线程为任务线程，</span></span><br><span class="line"><span class="comment">// 则直接将任务插入当前线程中的工作队列中；如果当前线程不是任务线程，则需要从池中先随机定位到一个工作线程，然后将任务插入。</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> m;</span><br><span class="line">    <span class="comment">//取得一个随机探查数，可能为0也可能为其它数</span></span><br><span class="line">    <span class="keyword">int</span> r = ThreadLocalRandom.getProbe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前ForkJoinPool的运行状态</span></span><br><span class="line">    <span class="keyword">int</span> rs = runState;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//工作队列列表不为空 &amp;&amp; 指定位置的工作队列不空 &amp;&amp; 成功将队列上锁</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SQMASK  = 0x007e = 0000 0000 0111 1110 = 126</span></span><br><span class="line"><span class="comment">     * 任何数和126进行“与”运算，其结果只可能是0或者偶数，所以 (m &amp; r &amp; SQMASK) 取出的是第偶数个队列，</span></span><br><span class="line"><span class="comment">     *  即索引位为偶数的工作队列用于存储从外部提交到ForkJoinPool中的任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (q = ws[m &amp; r &amp; SQMASK]) != <span class="keyword">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a; <span class="keyword">int</span> am, n, s;</span><br><span class="line">        <span class="keyword">if</span> ((a = q.array) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123; <span class="comment">//工作队列中有待处理子任务</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> j = ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;   <span class="comment">//待处理子任务的插入索引</span></span><br><span class="line">            <span class="comment">//将task放入队列</span></span><br><span class="line">            U.putOrderedObject(a, j, task);</span><br><span class="line">            <span class="comment">//将队列的top值加1</span></span><br><span class="line">            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            U.putIntVolatile(q, QLOCK, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果条件成立，说明这时处于active的工作线程可能还不够，所以调用signalWork方法</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                signalWork(ws, q);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在工作队列中没有待处理子任务时，释放锁</span></span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进行WorkQueue数组初始化</span></span><br><span class="line">    externalSubmit(task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现逻辑：</p>
<ol>
<li>获取一个随机探查数。该数用于定位（<code>m &amp; r &amp; SQMASK</code>）待提交任务要提交到哪个工作队列。</li>
<li>获取当前ForkJoinPool的运行状态</li>
<li><p>在池中的工作队列列表不为空 &amp;&amp; 指定位置的工作队列q不空，并成功将队列上锁，往下执行；否则，执行第4步。</p>
<ol>
<li>队列q内部的任务不为空且工作队列中有待处理任务，则执行下一步；否则释放锁后，执行第4步。</li>
<li>计算待处理任务的插入索引</li>
<li>通过CAS将任务入队，并修改队列的top值及释放锁</li>
<li>如果处于active状态的工作线程不够，则调用<code>signalWork</code>激活线程或新建线程</li>
<li>方法结束返回</li>
</ol>
</li>
<li><p>执行 <code>externalSubmit()</code> 方法，进行WorkQueue数组初始化及入队操作。</p>
</li>
</ol>
<h6 id="externalSubmit源码"><a href="#externalSubmit源码" class="headerlink" title="externalSubmit源码"></a>externalSubmit源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Full version of externalPush, handling uncommon cases, as well</span></span><br><span class="line"><span class="comment"> * as performing secondary initialization upon the first</span></span><br><span class="line"><span class="comment"> * submission of the first task to the pool.  It also detects</span></span><br><span class="line"><span class="comment"> * first submission by an external thread and creates a new shared</span></span><br><span class="line"><span class="comment"> * queue if the one at index if empty or contended.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task the task. Caller must ensure non-null.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r;                                    <span class="comment">// initialize caller's probe</span></span><br><span class="line">    <span class="comment">// 初始化探测器</span></span><br><span class="line">    <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        WorkQueue[] ws; WorkQueue q; <span class="keyword">int</span> rs, m, k;</span><br><span class="line">        <span class="keyword">boolean</span> move = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果当前ForkJoinPool的运行状态为SHUTDOWN，表明已被终止，不接受任务了。则尝试中断，并抛异常</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * RSLOCK     = 1</span></span><br><span class="line"><span class="comment">         * RSIGNAL    = 1 &lt;&lt; 1</span></span><br><span class="line"><span class="comment">         * STARTED    = 1 &lt;&lt; 2</span></span><br><span class="line"><span class="comment">         * STOP       = 1 &lt;&lt; 29</span></span><br><span class="line"><span class="comment">         * TERMINATED = 1 &lt;&lt; 30</span></span><br><span class="line"><span class="comment">         * SHUTDOWN   = 1 &lt;&lt; 31 (负数)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            tryTerminate(<span class="keyword">false</span>, <span class="keyword">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                ((ws = workQueues) == <span class="keyword">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;   <span class="comment">// 当前ForkJoinPool类中，还没有任何队列，所以要进行队列初始化</span></span><br><span class="line">            <span class="keyword">int</span> ns = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//获取runState锁</span></span><br><span class="line">            rs = lockRunState();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//判断是否已经初始化，正常（不考虑并发）情况是0。</span></span><br><span class="line">                <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 通过原子操作，完成“任务窃取次数”这个计数器的初始化</span></span><br><span class="line">                    U.compareAndSwapObject(<span class="keyword">this</span>, STEALCOUNTER, <span class="keyword">null</span>, <span class="keyword">new</span> AtomicLong());</span><br><span class="line">                    <span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line">                    <span class="comment">//创建数组大小为2的幂次方的工作队列</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> p = config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// n这个变量就是要计算的WorkQueue数组的大小</span></span><br><span class="line">                    <span class="keyword">int</span> n = (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     *  备注：SMASK = 0xffff。config = (parallelism &amp; SMASK) | mode;</span></span><br><span class="line"><span class="comment">                     *  模拟 mode = 0，则 config = parallelism</span></span><br><span class="line"><span class="comment">                     *  由计算机计算结果为：输出格式：parallelism&gt;&gt;&gt;&gt;&gt;数组大小</span></span><br><span class="line"><span class="comment">                         1&gt;&gt;&gt;&gt;&gt;4</span></span><br><span class="line"><span class="comment">                         2&gt;&gt;&gt;&gt;&gt;4</span></span><br><span class="line"><span class="comment">                         3&gt;&gt;&gt;&gt;&gt;8</span></span><br><span class="line"><span class="comment">                         4&gt;&gt;&gt;&gt;&gt;8</span></span><br><span class="line"><span class="comment">                         5&gt;&gt;&gt;&gt;&gt;16</span></span><br><span class="line"><span class="comment">                         6&gt;&gt;&gt;&gt;&gt;16</span></span><br><span class="line"><span class="comment">                         7&gt;&gt;&gt;&gt;&gt;16</span></span><br><span class="line"><span class="comment">                         8&gt;&gt;&gt;&gt;&gt;16</span></span><br><span class="line"><span class="comment">                         9&gt;&gt;&gt;&gt;&gt;32</span></span><br><span class="line"><span class="comment">                         10&gt;&gt;&gt;&gt;&gt;32</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">1</span>; n |= n &gt;&gt;&gt; <span class="number">2</span>;  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">8</span>; n |= n &gt;&gt;&gt; <span class="number">16</span>; n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    workQueues = <span class="keyword">new</span> WorkQueue[n];</span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="keyword">null</span>) &#123;    <span class="comment">//和externalPush方法的实现逻辑大体一致</span></span><br><span class="line">            <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;</span><br><span class="line">                <span class="keyword">int</span> s = q.top;</span><br><span class="line">                <span class="keyword">boolean</span> submitted = <span class="keyword">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">                <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                    <span class="keyword">if</span> ((a != <span class="keyword">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                            (a = q.growArray()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> j = (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        U.putOrderedObject(a, j, task);</span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);</span><br><span class="line">                        submitted = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果task成功提交，会尝试启动worker</span></span><br><span class="line">                <span class="keyword">if</span> (submitted) &#123;</span><br><span class="line">                    signalWork(ws, q);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move on failure</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">            q = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">            q.hint = r;</span><br><span class="line">            q.config = k | SHARED_QUEUE;</span><br><span class="line">            q.scanState = INACTIVE;</span><br><span class="line">            rs = lockRunState();           <span class="comment">// publish index</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp;  (ws = workQueues) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    k &lt; ws.length &amp;&amp; ws[k] == <span class="keyword">null</span>)</span><br><span class="line">                ws[k] = q;                 <span class="comment">// else terminated</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            move = <span class="keyword">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">        <span class="keyword">if</span> (move)</span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>功能分析：在调用<code>externalPush()</code>方法将任务入队时，如果待插入任务定位到的工作队列没空或者锁定失败，则会调用<code>externalSubmit()</code>方法。从方法注释可知，<code>externalSubmit()</code>方法是完整版的<code>externalPush()</code>方法。该方法处理不常见的情况，以及在首次将第一个任务提交到池时执行辅助初始化。如果索引处的为空或争用，它还检测外部线程的第一次提交，并创建一个新的共享队列。</p>
<p>实现逻辑：</p>
<ol>
<li>初始化探测器。该探测器产生的随机数用于定位工作队列索引。</li>
<li>进入无限循环，失败即重试，直至任务成功入队<ol>
<li>如果当前ForkJoinPool的运行状态为SHUTDOWN，表明已被终止，不接受任务了。则尝试中断，并抛异常</li>
<li>如果当前ForkJoinPool对象需要初始化，则进行初始化操作。循环继续</li>
<li>如果定位的索引处工作队列不为空，则加锁将任务入队。在入队的过程中，如需扩容，则进行扩容操作。</li>
<li>如果定位的索引处工作队列为空，则初始化该线程对应的工作队列。循环继续</li>
</ol>
</li>
</ol>
<p>在将任务入队的过程中，如果需要扩容，则会调用WorkerQueue类中的<code>growArray()</code>方法进行扩容操作。</p>
<h6 id="growArray源码"><a href="#growArray源码" class="headerlink" title="growArray源码"></a>growArray源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes or doubles the capacity of array. Call either</span></span><br><span class="line"><span class="comment"> * by owner or with lock held -- it is OK for base, but not</span></span><br><span class="line"><span class="comment"> * top, to move while resizings are in progress.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//该方法会初始化或者进行队列2倍扩容</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt;[] growArray() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] oldA = array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size = oldA != <span class="keyword">null</span> ? oldA.length &lt;&lt; <span class="number">1</span> : INITIAL_QUEUE_CAPACITY;    <span class="comment">//如果首次初始化，则数组默认大小为2^13。否则，在原基础上扩容2倍</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAXIMUM_QUEUE_CAPACITY)  <span class="comment">//如果数组越界，则抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Queue capacity exceeded"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> oldMask, t, b;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array = <span class="keyword">new</span> ForkJoinTask&lt;?&gt;[size];</span><br><span class="line">    <span class="keyword">if</span> (oldA != <span class="keyword">null</span> &amp;&amp; (oldMask = oldA.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (t = top) - (b = base) &gt; <span class="number">0</span>) &#123;   <span class="comment">//原数组有元素，则进行数组拷贝</span></span><br><span class="line">        <span class="keyword">int</span> mask = size - <span class="number">1</span>;    <span class="comment">//计算元素索引的掩码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//从base（下一个出队元素的索引位）位置开始拷贝原数组元素到新数组</span></span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// emulate poll from old array, push to new array</span></span><br><span class="line">            ForkJoinTask&lt;?&gt; x;</span><br><span class="line">            <span class="keyword">int</span> oldj = ((b &amp; oldMask) &lt;&lt; ASHIFT) + ABASE;   <span class="comment">//旧元素的索引</span></span><br><span class="line">            <span class="keyword">int</span> j    = ((b &amp;    mask) &lt;&lt; ASHIFT) + ABASE;   <span class="comment">//新元素的索引</span></span><br><span class="line">            x = (ForkJoinTask&lt;?&gt;)U.getObjectVolatile(oldA, oldj);   <span class="comment">//获取要移动的元素</span></span><br><span class="line">            <span class="keyword">if</span> (x != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(oldA, oldj, x, <span class="keyword">null</span>))    <span class="comment">//如果元素不为空，且成功将旧数组相应位置置空</span></span><br><span class="line">                U.putObjectVolatile(a, j, x);   <span class="comment">//拷贝到新数组</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (++b != t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法实现逻辑相对比较简单。就是进行工作队列的初始化或者2倍扩容操作。在确定好工作队列中的新工作任务的数组大小后<code>int size = oldA != null ? oldA.length &lt;&lt; 1 : INITIAL_QUEUE_CAPACITY;</code>，在没有超过最大数组容量的前提下，会依次从旧数组中拷贝元素到新数组中。</p>
<p>在将任务成功入队后，还会通过调用<code>signalWork()</code>方法来启动worker</p>
<h6 id="signalWork源码"><a href="#signalWork源码" class="headerlink" title="signalWork源码"></a>signalWork源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to create or activate a worker if too few are active.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ws the worker array to use to find signallees</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> q a WorkQueue --if non-null, don't retry if now empty</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">//如果工作者太少活跃的话，则尝试新建或激活工作者</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> c; <span class="keyword">int</span> sp, i; WorkQueue v; Thread p;</span><br><span class="line">    <span class="comment">//这里初始化后的ctl是个long型负数，但是转换成int后，变成0</span></span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="keyword">int</span>)c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                <span class="comment">//初始状态，会调用这个方法，调用完退出</span></span><br><span class="line">                tryAddWorker(c);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="keyword">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="keyword">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> vs = (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">        <span class="keyword">int</span> d = sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">        <span class="keyword">long</span> nc = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="keyword">null</span>)</span><br><span class="line">                U.unpark(p);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要是在有任务添加到工作队列后调用。该方法主要功能是：在工作者活跃的太少时，会新增或者激活工作者。</p>
<h6 id="tryAddWorker源码"><a href="#tryAddWorker源码" class="headerlink" title="tryAddWorker源码"></a>tryAddWorker源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryAddWorker</span><span class="params">(<span class="keyword">long</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> add = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> nc = ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">        <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">            <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                createWorker();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="keyword">int</span>)c == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会经过一系列判断，最终调用<code>createWorker()</code>方法进行工作者的新增。</p>
<h6 id="createWorker源码"><a href="#createWorker源码" class="headerlink" title="createWorker源码"></a>createWorker源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tries to construct and start one worker. Assumes that total</span></span><br><span class="line"><span class="comment"> * count has already been incremented as a reservation.  Invokes</span></span><br><span class="line"><span class="comment"> * deregisterWorker on any failure.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if successful</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ForkJoinWorkerThreadFactory fac = factory;</span><br><span class="line">    Throwable ex = <span class="keyword">null</span>;</span><br><span class="line">    ForkJoinWorkerThread wt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="keyword">null</span> &amp;&amp; (wt = fac.newThread(<span class="keyword">this</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    deregisterWorker(wt, ex);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会通过<code>ForkJoinWorkerThreadFactory</code>对象构建<code>ForkJoinWorkerThread</code>类型线程，然后启动线程，进行任务处理。在上面我们已经对 ForkJoinWorkerThread 类进行了简单分析，其<code>run()</code> 方法内部调用了 ForkJoinPool 类的 <code>runWorker()</code> 方法。</p>
<h6 id="runWorker源码"><a href="#runWorker源码" class="headerlink" title="runWorker源码"></a>runWorker源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Top-level runloop for workers, called by ForkJoinWorkerThread.run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(WorkQueue w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分配工作队列，初始化或者扩容</span></span><br><span class="line">    w.growArray();                   <span class="comment">// allocate queue</span></span><br><span class="line">    <span class="keyword">int</span> seed = w.hint;               <span class="comment">// initially holds randomization hint</span></span><br><span class="line">    <span class="comment">//准备偷取的队列索引</span></span><br><span class="line">    <span class="keyword">int</span> r = (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  <span class="comment">// avoid 0 for xorShift</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="keyword">null</span>)   <span class="comment">//调用scan尝试去偷取一个任务,然后调用runTask或者awaitWork</span></span><br><span class="line">            w.runTask(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))  <span class="comment">//如果任务中断，返回false</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>; r ^= r &gt;&gt;&gt; <span class="number">17</span>; r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现逻辑：</p>
<ol>
<li>进行工作队列的扩容操作</li>
<li>获取随机数，用户确定窃取任务的队列</li>
<li>进行无限循环。<ol>
<li>调用<code>scan()</code>方法尝试窃取一个任务t</li>
<li>如果窃取的任务t不为空，则调用<code>runTask()</code>方法执行任务</li>
<li>如果窃取的任务t为空，则调用<code>awaitWork()</code>方法阻塞工作线程等待窃取任务。如果任务中断，break跳出循环结束。</li>
<li>重新定位，再次循环</li>
</ol>
</li>
</ol>
<h6 id="scan源码"><a href="#scan源码" class="headerlink" title="scan源码"></a>scan源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scans for and tries to steal a top-level task. Scans start at a</span></span><br><span class="line"><span class="comment"> * random location, randomly moving on apparent contention,</span></span><br><span class="line"><span class="comment"> * otherwise continuing linearly until reaching two consecutive</span></span><br><span class="line"><span class="comment"> * empty passes over all queues with the same checksum (summing</span></span><br><span class="line"><span class="comment"> * each base index of each queue, that moves on each steal), at</span></span><br><span class="line"><span class="comment"> * which point the worker tries to inactivate and then re-scans,</span></span><br><span class="line"><span class="comment"> * attempting to re-activate (itself or some other worker) if</span></span><br><span class="line"><span class="comment"> * finding a task; otherwise returning null to await work.  Scans</span></span><br><span class="line"><span class="comment"> * otherwise touch as little memory as possible, to reduce</span></span><br><span class="line"><span class="comment"> * disruption on other scanning threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w the worker (via its WorkQueue)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> r a random seed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a task, or null if none found</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//扫描并尝试窃取顶级任务。</span></span><br><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="keyword">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws; <span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="keyword">null</span>) &#123; <span class="comment">//任务队列列表不为空</span></span><br><span class="line">        <span class="keyword">int</span> ss = w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> origin = r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>;;) &#123;</span><br><span class="line">            WorkQueue q; ForkJoinTask&lt;?&gt;[] a; ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            <span class="keyword">int</span> b, n; <span class="keyword">long</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (a = q.array) != <span class="keyword">null</span>) &#123;      <span class="comment">// non-empty 有任务</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//获取索引。在扫描任务时，从工作队列的尾部进行扫描</span></span><br><span class="line">                    <span class="keyword">long</span> i = (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                            U.getObjectVolatile(a, i))) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            q.base == b) &#123;  <span class="comment">//指定索引处的任务不空且没有其他线程并行操作</span></span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                                q.base = b + <span class="number">1</span>;</span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                                    signalWork(ws, q);</span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate</span></span><br><span class="line">                                w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="keyword">int</span>)c], AC_UNIT);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>; r ^= r &gt;&gt;&gt; <span class="number">3</span>; r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果我们遍历了一圈(((k = (k + 1) &amp; m) == origin))都没有偷到,我们就认为当前的active 线程过剩了,我们准备将当前的线程(即owner)挂起</span></span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                        oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">int</span> ns = ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                    <span class="keyword">long</span> nc = ((SP_MASK &amp; ns) |</span><br><span class="line">                            (UC_MASK &amp; ((c = ctl) - AC_UNIT)));</span><br><span class="line">                    w.stackPred = (<span class="keyword">int</span>)c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);</span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="keyword">this</span>, CTL, c, nc))</span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要是扫描尝试从其他工作队列窃取任务。大致逻辑为：</p>
<ol>
<li>判断池中的工作队列是否为空，在不为空的情况下，执行下一步；否则，直接返回null。</li>
<li>进入for循环，根据随机数确定待窃取任务的工作队列（即从这个队列中窃取任务）索引。</li>
<li>待窃取任务的工作队列不为空，且有任务的情况下，从队列的尾部（base位置）获取待窃取任务索引。</li>
<li>满足一定条件下，获取指定索引处的任务，并返回。</li>
<li>如果没有窃取到任务，说明工作线程过剩，此时将当前线程挂起，然后跳出循环，方法结束。</li>
</ol>
<p>我们在分析 <a href="https://houlong123.github.io/2017/12/21/Fork-Join框架源码学习之ForkJoinTask学习/">ForkJoinTask</a> 时有说过：<code>在线程处理自己内部的工作队列时，是从头部开始，即pop()；但是在窃取工作帮助其他线程处理任务时，是从尾部开始，即poll()。</code></p>
<h6 id="registerWorker源码"><a href="#registerWorker源码" class="headerlink" title="registerWorker源码"></a>registerWorker源码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback from ForkJoinWorkerThread constructor to establish and</span></span><br><span class="line"><span class="comment"> * record its WorkQueue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> wt the worker thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the worker's queue</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> WorkQueue <span class="title">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> </span>&#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    <span class="comment">//将工作线程设置为后台线程</span></span><br><span class="line">    wt.setDaemon(<span class="keyword">true</span>);                           <span class="comment">// configure thread</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置异常处理类</span></span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="keyword">null</span>)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建工作队列</span></span><br><span class="line">    WorkQueue w = <span class="keyword">new</span> WorkQueue(<span class="keyword">this</span>, wt);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line">    <span class="comment">//确定工作队列的类型</span></span><br><span class="line">    <span class="keyword">int</span> mode = config &amp; MODE_MASK;</span><br><span class="line">    <span class="keyword">int</span> rs = lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws; <span class="keyword">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//池中有工作队列列表时，将新创建的工作队列添加进去。在添加的过程中，如果池中有工作队列列表容量不够，则需要进行2倍扩容操作</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="keyword">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> s = indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">            <span class="keyword">int</span> m = n - <span class="number">1</span>;</span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// odd-numbered indices</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="keyword">null</span>) &#123;                  <span class="comment">// collision</span></span><br><span class="line">                <span class="keyword">int</span> probes = <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">                <span class="keyword">int</span> step = (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;</span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);</span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法是在<code>ForkJoinWorkerThread</code> 的构造函数中被调用，主要用来创建工作队列。代码的实现逻辑相对比较简单：设置线程属性，然后将新建的工作队列丢进池中的工作队列列表。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://houlong123.github.io/2017/12/25/Fork-Join框架源码学习之ForkJoinPool学习/" data-id="cjfhpc29k000tl80mujf59ixz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java并发/">java并发</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/28/Linux系统dokuwiki部署/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Linux系统dokuwiki部署
        
      </div>
    </a>
  
  
    <a href="/2017/12/21/Fork-Join框架源码学习之ForkJoinTask学习/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Fork/Join框架源码学习之ForkJoinTask学习</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dokuwiki部署/">dokuwiki部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java基础集合/">java基础集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发/">java并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发锁/">java并发锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发集合/">java并发集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/部署GitHub-Page/">部署GitHub Page</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mysql/" style="font-size: 11.43px;">Mysql</a> <a href="/tags/Spring/" style="font-size: 14.29px;">Spring</a> <a href="/tags/dokuwiki部署/" style="font-size: 10px;">dokuwiki部署</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 20px;">java</a> <a href="/tags/java基础集合/" style="font-size: 18.57px;">java基础集合</a> <a href="/tags/java并发/" style="font-size: 12.86px;">java并发</a> <a href="/tags/java并发锁/" style="font-size: 15.71px;">java并发锁</a> <a href="/tags/java并发集合/" style="font-size: 17.14px;">java并发集合</a> <a href="/tags/部署GitHub-Page/" style="font-size: 10px;">部署GitHub Page</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/02/类初始化顺序/">类初始化顺序</a>
          </li>
        
          <li>
            <a href="/2018/04/01/JVM额外知识学习/">JVM额外知识学习</a>
          </li>
        
          <li>
            <a href="/2018/03/20/Integer类学习/">Integer类学习</a>
          </li>
        
          <li>
            <a href="/2018/03/18/JVM-学习/">JVM 学习</a>
          </li>
        
          <li>
            <a href="/2018/02/26/TreeMap源码学习/">TreeMap源码学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 houlong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
  <a href="https://github.com/houlong123"><img style="position: absolute; top: 0; right: 0; border: 0; z-index: 1000;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
</body>
</html>
