<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Fork/Join框架源码学习之ForkJoinTask学习 | 而今伊始，命途自闯</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言Fork/Join框架是一个用于并行执行任务的框架，核心是：把一个大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果。体现了分而治之的思想。类似于算法中的归并排序。该框架之所以有更好的并发性能，是因为其充分利用了所有线程的工作能力，避免空闲线程，充分发挥多核并行的处理能力。  使用预备知识点在java的官方文档介绍Fork/Join中，可以知道Fork/Join框架的基本使用的伪">
<meta name="keywords" content="java并发">
<meta property="og:type" content="article">
<meta property="og:title" content="Fork&#x2F;Join框架源码学习之ForkJoinTask学习">
<meta property="og:url" content="https://houlong123.github.io/2017/12/21/Fork-Join框架源码学习之ForkJoinTask学习/index.html">
<meta property="og:site_name" content="而今伊始，命途自闯">
<meta property="og:description" content="前言Fork/Join框架是一个用于并行执行任务的框架，核心是：把一个大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果。体现了分而治之的思想。类似于算法中的归并排序。该框架之所以有更好的并发性能，是因为其充分利用了所有线程的工作能力，避免空闲线程，充分发挥多核并行的处理能力。  使用预备知识点在java的官方文档介绍Fork/Join中，可以知道Fork/Join框架的基本使用的伪">
<meta property="og:image" content="http://www.oracle.com/ocom/groups/public/@otn/documents/digitalasset/422590.png">
<meta property="og:updated_time" content="2018-01-25T07:14:04.940Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Fork&#x2F;Join框架源码学习之ForkJoinTask学习">
<meta name="twitter:description" content="前言Fork/Join框架是一个用于并行执行任务的框架，核心是：把一个大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果。体现了分而治之的思想。类似于算法中的归并排序。该框架之所以有更好的并发性能，是因为其充分利用了所有线程的工作能力，避免空闲线程，充分发挥多核并行的处理能力。  使用预备知识点在java的官方文档介绍Fork/Join中，可以知道Fork/Join框架的基本使用的伪">
<meta name="twitter:image" content="http://www.oracle.com/ocom/groups/public/@otn/documents/digitalasset/422590.png">
  
    <link rel="alternate" href="/atom.xml" title="而今伊始，命途自闯" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">而今伊始，命途自闯</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://houlong123.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Fork-Join框架源码学习之ForkJoinTask学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/21/Fork-Join框架源码学习之ForkJoinTask学习/" class="article-date">
  <time datetime="2017-12-21T07:12:04.000Z" itemprop="datePublished">2017-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Fork/Join框架源码学习之ForkJoinTask学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Fork/Join框架是一个用于并行执行任务的框架，核心是：<font color="red">把一个大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果。</font>体现了<code>分而治之</code>的思想。类似于算法中的<code>归并排序</code>。该框架之所以有更好的并发性能，是因为其充分利用了所有线程的工作能力，避免空闲线程，充分发挥多核并行的处理能力。</p>
<p><img src="http://www.oracle.com/ocom/groups/public/@otn/documents/digitalasset/422590.png" alt="image"></p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h5 id="预备知识点"><a href="#预备知识点" class="headerlink" title="预备知识点"></a>预备知识点</h5><p>在java的官方文档介绍<a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html" target="_blank" rel="noopener">Fork/Join</a>中，可以知道Fork/Join框架的基本使用的伪代码为：</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (my portion of the work is small enough)</span><br><span class="line">   <span class="keyword">do</span> the work directly</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   split my work into two pieces</span><br><span class="line">   invoke the two pieces and wait <span class="keyword">for</span> the results</span><br></pre></td></tr></table></figure>
<p>在使用的时候， 将这些伪代码封装到<code>ForkJoinTask</code>的子类中。通常使用的<code>ForkJoinTask</code>的子类是：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveTask.html" target="_blank" rel="noopener"><code>RecursiveTask（有返回结果）</code></a> 和 <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/RecursiveAction.html" target="_blank" rel="noopener"><code>RecursiveAction（无返回结果）</code></a>。我们只要根据需要，继承这两个类中的一个，并实现其中的方法，即可实现自己定义的任务类。然后在使用<code>ForkJoinPool</code>去执行任务。</p>
<h5 id="使用实例：排序"><a href="#使用实例：排序" class="headerlink" title="使用实例：排序"></a>使用实例：排序</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> inits[] = <span class="keyword">new</span> <span class="keyword">int</span>[MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX; i++) &#123;</span><br><span class="line">            inits[i] = random.nextInt(<span class="number">1000000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> a[] = inits.clone();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1. Create a task that represents all of the work to be done.</span></span><br><span class="line">        SortTask task  = <span class="keyword">new</span> SortTask(a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2. Create the ForkJoinPool that will run the task</span></span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"排序前："</span> + Arrays.toString(a));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3. Run the task</span></span><br><span class="line">        pool.submit(task);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.MILLISECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(!task.isDone());</span><br><span class="line">        System.out.println(<span class="string">"排序后："</span> + Arrays.toString(a));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 继承ForkJoinTask的子类RecursiveAction。由于是没有返回，所以需要在获取之前，先判断任务是否已完成，没有完成的话，继续等待。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SortTask</span> <span class="keyword">extends</span> <span class="title">RecursiveAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THRESHOLD = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] array; <span class="keyword">final</span> <span class="keyword">int</span> lo, hi;</span><br><span class="line">        </span><br><span class="line">        SortTask(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">            <span class="keyword">this</span>.array = array; <span class="keyword">this</span>.lo = lo; <span class="keyword">this</span>.hi = hi;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SortTask(<span class="keyword">int</span>[] array) &#123; <span class="keyword">this</span>(array, <span class="number">0</span>, array.length); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (hi - lo &lt; THRESHOLD) &#123;</span><br><span class="line">                sortSequentially(lo, hi);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (lo + hi) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                invokeAll(<span class="keyword">new</span> SortTask(array, lo, mid),</span><br><span class="line">                        <span class="keyword">new</span> SortTask(array, mid, hi));</span><br><span class="line">                        </span><br><span class="line">                 <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 另一种方式，与invokeAll实现逻辑一样。</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 * 备注：需要注意的是，join调用顺序要与fork的调用顺序相反。具体原因由下文源码分析可知。</span></span><br><span class="line"><span class="comment">                 * 或看博客https://yq.aliyun.com/articles/48736?spm=5176.100239.blogcont48737.8.txj280</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 *   SortTask right = new SortTask(array, lo, mid);</span></span><br><span class="line"><span class="comment">                 *   SortTask left = new SortTask(array, mid, hi);</span></span><br><span class="line"><span class="comment">                 *    //任务分解</span></span><br><span class="line"><span class="comment">                 *    right.fork();</span></span><br><span class="line"><span class="comment">                 *    left.fork();</span></span><br><span class="line"><span class="comment">                 *</span></span><br><span class="line"><span class="comment">                 *    //任务结果合并</span></span><br><span class="line"><span class="comment">                 *    left.join();</span></span><br><span class="line"><span class="comment">                 *    right.join();</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                merge(lo, mid, hi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sortSequentially</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">            Arrays.sort(array, lo, hi);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span>[] buf = Arrays.copyOfRange(array, lo, mid);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = lo, k = mid; i &lt; buf.length; j++) &#123;</span><br><span class="line">                array[j] = (k == hi || buf[i] &lt; array[k]) ? buf[i++] : array[k++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><p>由上面的使用实例可知，Fork/Join框架的使用，分为三个步骤：</p>
<ol>
<li>创建任务</li>
<li>创建执行任务的线程池ForkJoinPool对象。</li>
<li>执行任务</li>
</ol>
<p>首先我们分析<code>ForkJoinTask</code>源码</p>
<h4 id="ForkJoinTask源码分析"><a href="#ForkJoinTask源码分析" class="headerlink" title="ForkJoinTask源码分析"></a>ForkJoinTask源码分析</h4><h5 id="内部数据结构"><a href="#内部数据结构" class="headerlink" title="内部数据结构"></a>内部数据结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The run status of this task */</span></span><br><span class="line">    <span class="comment">// 任务运行状态，下面是转换为十进制的值。可知，在状态为SIGNAL或者SMASK时，才会大于0</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *   DONE_MASK = -268435456</span></span><br><span class="line"><span class="comment">         NORMAL = -268435456</span></span><br><span class="line"><span class="comment">         CANCELLED = -1073741824</span></span><br><span class="line"><span class="comment">         EXCEPTIONAL = -2147483648</span></span><br><span class="line"><span class="comment">         SIGNAL = 65536</span></span><br><span class="line"><span class="comment">         SMASK = 65535</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> status; <span class="comment">// accessed directly by pool and workers</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DONE_MASK   = <span class="number">0xf0000000</span>;  <span class="comment">// mask out non-completion bits</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL      = <span class="number">0xf0000000</span>;  <span class="comment">// must be negative</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED   = <span class="number">0xc0000000</span>;  <span class="comment">// must be &lt; NORMAL</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL = <span class="number">0x80000000</span>;  <span class="comment">// must be &lt; CANCELLED</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL      = <span class="number">0x00010000</span>;  <span class="comment">// must be &gt;= 1 &lt;&lt; 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SMASK       = <span class="number">0x0000ffff</span>;  <span class="comment">// short bits for tags</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ForkJoinTask类继承了<code>Future</code>类。该类内部主要是有个属性，记录任务的执行状态。由使用实例可知，ForkJoinTask类的主要方法是：fork，join，invokeAll等，下面进行主要方法分析</p>
<h5 id="fork源码"><a href="#fork源码" class="headerlink" title="fork源码"></a>fork源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将任务进行拆分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title">fork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果当前的线程是Fork/join的线程,就添加到队列中</span></span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//当task是直接被调用,而不是使用ForkJoinWorkerThread的话,直接执行任务.</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的主要功能是：<code>将任务进行拆分</code>。在内部实现中，如果当前线程为<code>ForkJoinWorkerThread</code>线程时，则直接将该任务添加进当前线程的工作队列中；否则，则通过线程池<code>ForkJoinPool</code>将任务添加到池中的随机一个工作队列中。具体逻辑，后文再分析。</p>
<h5 id="join源码"><a href="#join源码" class="headerlink" title="join源码"></a>join源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行子任务并合并子任务的结果集</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">join</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的功能是：<code>执行子任务并合并子任务的结果集</code>。内部实现中，会调用<code>doJoin()</code>方法，执行任务，如果执行成功，则调用抽象方法<code>getRawResult()</code>返回执行结果；否则，执行<code>reportException()</code>方法处理异常。</p>
<h5 id="doJoin源码"><a href="#doJoin源码" class="headerlink" title="doJoin源码"></a>doJoin源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//doJoin方法是进行合并,合并之前需要进行判断,看当前的任务是否可以执行,如果可以执行则调用doExec方法,如果不能执行则加入等待的队列</span></span><br><span class="line"><span class="comment">//在join获取执行任务时，是从队列的头部开始，而在sacn窃取工作任务时，是从队列的尾部开始</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doJoin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断执行的状态</span></span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断是否fork/join的线程</span></span><br><span class="line">            ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//判断是否在队列的头部 &amp;&amp; 在执行头部</span></span><br><span class="line">                    (w = (wt = (ForkJoinWorkerThread)t).workQueue).tryUnpush(<span class="keyword">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">                            <span class="comment">//加入到等待的队列</span></span><br><span class="line">                            wt.pool.awaitJoin(w, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">                    <span class="comment">//不是fork/join线程 阻塞</span></span><br><span class="line">                    externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现逻辑：</p>
<ol>
<li>判断任务的执行状态status。如果<code>status &lt; 0</code>，则直接返回；否则执行第2步</li>
<li>判断当前的任务是否可以执行,如果可以执行则调用doExec方法,如果不能执行则加入等待的队列。具体逻辑为：<ol>
<li>如果当前线程为<code>ForkJoinWorkerThread</code>线程，则从当前线程的工作队列中弹出顶部任务，并执行该任务。如果执行成功，则返回；否则，如果执行失败，则将任务加入到等待的队列。（帮助其他线程处理任务，即窃取任务 或者阻塞直到任务完成或超时）</li>
<li>如果不是<code>ForkJoinWorkerThread</code>线程fork/join线程 阻塞</li>
</ol>
</li>
</ol>
<p>在ForkJoinPool类有关<code>WorkQueue</code>介绍如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The pop <span class="title">operation</span> <span class="params">(always performed by owner)</span> is:</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">((base != top)</span> and</span></span><br><span class="line"><span class="function">       <span class="params">(the task at top slot is not <span class="keyword">null</span>)</span> <span class="title">and</span> <span class="params">(CAS slot to <span class="keyword">null</span>)</span>)</span></span><br><span class="line"><span class="function">          decrement top and return task</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">And the poll <span class="title">operation</span> <span class="params">(usually by a stealer)</span> is</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">((base != top)</span> and</span></span><br><span class="line"><span class="function">       <span class="params">(the task at base slot is not <span class="keyword">null</span>)</span> and </span></span><br><span class="line"><span class="function">       <span class="params">(base has not changed)</span> and</span></span><br><span class="line"><span class="function">       <span class="params">(CAS slot to <span class="keyword">null</span>)</span>)</span></span><br><span class="line"><span class="function">          increment base and return task</span>;</span><br></pre></td></tr></table></figure>
<p>可知，在线程处理自己内部的工作队列时，是从头部开始，即pop()；但是在窃取工作帮助其他线程处理任务时，是从尾部开始，即poll()。</p>
<p>所以在<code>doJoin()</code>中，如果为<code>ForkJoinWorkerThread</code>线程时，会调用<code>tryUnpush()</code>方法从头部获取待处理任务。</p>
<h5 id="doExec源码"><a href="#doExec源码" class="headerlink" title="doExec源码"></a>doExec源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">doExec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; <span class="keyword">boolean</span> completed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断任务状态,是否执行</span></span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//在ForkJoinTask两个子类中的实现方式都是调用compute()方法。compute()方法就是Fork Join要执行的内容，是Fork Join任务的实质，需要开发者实现</span></span><br><span class="line">            completed = exec();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//完成任务,修改状态</span></span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的功能是：执行任务。在之前前会判断任务状态，如果任务可执行，则调用<code>exec()</code>方法，由继承关系可知，实际调用的是<code>ForkJoinTask</code>子类的相应实现。在<code>RecursiveAction</code> 和 <code>RecursiveTask</code>中，都是调用了<code>compute()</code>方法。即调用了开发者自己的实现逻辑。在执行成功后，会通过setCompletion()方法设置任务的状态。</p>
<h5 id="externalAwaitDone源码"><a href="#externalAwaitDone源码" class="headerlink" title="externalAwaitDone源码"></a>externalAwaitDone源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻止非工作线程直到完成。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">externalAwaitDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行任务。如果是CountedCompleter子类，则调用externalHelpComplete()方法；否则执行tryExternalUnpush()方法，弹出任务，并执行</span></span><br><span class="line">    <span class="keyword">int</span> s = ((<span class="keyword">this</span> <span class="keyword">instanceof</span> CountedCompleter) ? <span class="comment">// try helping</span></span><br><span class="line">            ForkJoinPool.common.externalHelpComplete((CountedCompleter&lt;?&gt;)<span class="keyword">this</span>, <span class="number">0</span>) :</span><br><span class="line">            ForkJoinPool.common.tryExternalUnpush(<span class="keyword">this</span>) ? doExec() : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务状态大于0，说明任务还未成功处理，则中断</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span> &amp;&amp; (s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, STATUS, s, s | SIGNAL)) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;  <span class="comment">//任务状态为SIGNAL，则中断此任务</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait(<span class="number">0L</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                            interrupted = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>    <span class="comment">//唤醒所有线程</span></span><br><span class="line">                        notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((s = status) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="invoke源码"><a href="#invoke源码" class="headerlink" title="invoke源码"></a>invoke源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行任务并返回执行结果。如有必要，需等待任务完成</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">invoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doInvoke() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法主要是：<code>执行任务并返回执行结果</code>。其内部实现与<code>join()</code>方法类似，但是在实现任务执行的逻辑时其内部调用的是<code>doInvoke()</code>方法。<code>doInvoke()</code>方法与<code>doJoin()</code>方法内部实现逻辑也很类似。</p>
<h5 id="doInvoke源码"><a href="#doInvoke源码" class="headerlink" title="doInvoke源码"></a>doInvoke源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行任务。执行成功直接返回；执行失败后，如果属于Fork/join的线程,将任务添加到等待队列；否则阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">doInvoke</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s; Thread t; ForkJoinWorkerThread wt;</span><br><span class="line">    <span class="keyword">return</span> (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">            ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">                    <span class="comment">//加入到等待的队列</span></span><br><span class="line">                    (wt = (ForkJoinWorkerThread)t).pool.awaitJoin(wt.workQueue, <span class="keyword">this</span>, <span class="number">0L</span>) :</span><br><span class="line">                    <span class="comment">//不是fork/join线程 阻塞</span></span><br><span class="line">                    externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法功能和<code>doJoin()</code>方法也很类似。区别是：doInvoke()方法直接调用<code>doExec()</code>方法执行任务。执行成功，直接返回；否则，判断是否为<code>ForkJoinWorkerThread</code>线程。是，调用<code>awaitJoin()</code>方法将任务添加到等待的队列；否则调用<code>externalAwaitDone()</code>阻塞任务。</p>
<h5 id="invokeAll源码"><a href="#invokeAll源码" class="headerlink" title="invokeAll源码"></a>invokeAll源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeAll</span><span class="params">(ForkJoinTask&lt;?&gt; t1, ForkJoinTask&lt;?&gt; t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s1, s2;</span><br><span class="line">    t2.fork();  <span class="comment">//调用子任务2的fork()方法，将任务添加到工作队列</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先执行子任务1</span></span><br><span class="line">    <span class="keyword">if</span> ((s1 = t1.doInvoke() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        t1.reportException(s1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用子任务2的doJoin()，执行任务</span></span><br><span class="line">    <span class="keyword">if</span> ((s2 = t2.doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        t2.reportException(s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invokeAll()方法将处理两个子任务。由内部实现可知，实现逻辑是：现将子任务2放进工作队列，然后执行子任务1，在子任务1处理完后，执行子任务2。该方法等同于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务拆分</span></span><br><span class="line">t2.fork();</span><br><span class="line">t1.fork();</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并结果集</span></span><br><span class="line">t1.join();</span><br><span class="line">t2.join();</span><br></pre></td></tr></table></figure>
<p>但需要注意的是，子任务t1,t2调用<code>join()</code>方法的顺序要与调用<code>fork()</code>方法的顺序相反。因为在后面分析<code>ForkJoinPool</code>的入队逻辑时，我们可以知道，t1会放置在工作队列的top位置，而在<code>join()</code>时，会从工作队列的top位置取出任务并执行，如果执行的任务不是top位置的任务的话，线程最终只能挂起阻塞，等待通知。有关信息可以 <a href="https://yq.aliyun.com/articles/48736?spm=5176.100239.blogcont48739.13.zi6zna" target="_blank" rel="noopener">点击查看</a></p>
<h4 id="ForkJoinTask重要实现类"><a href="#ForkJoinTask重要实现类" class="headerlink" title="ForkJoinTask重要实现类"></a>ForkJoinTask重要实现类</h4><h5 id="RecursiveTask源码"><a href="#RecursiveTask源码" class="headerlink" title="RecursiveTask源码"></a>RecursiveTask源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5232453952276485270L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The result of the computation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    V result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the result of the computation</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//抽象方法。由开发者自己实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> V <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果处理值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getRawResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        result = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements execution conventions for RecursiveTask.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//执行任务。内部调用compute()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        result = compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/RecursiveTask.html" target="_blank" rel="noopener">RecursiveTask</a> 类是<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ForkJoinTask.html" target="_blank" rel="noopener">ForkJoinTask</a>的子类，该类会有返回值。在并发任务中，如果需要处理结果有返回值的话，继承该类并实现<code>compute()</code>即可。</p>
<h5 id="RecursiveAction源码"><a href="#RecursiveAction源码" class="headerlink" title="RecursiveAction源码"></a>RecursiveAction源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RecursiveAction</span> <span class="keyword">extends</span> <span class="title">ForkJoinTask</span>&lt;<span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5232453952276485070L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The main computation performed by this task.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//抽象方法。由开发者自己实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Always returns &#123;<span class="doctag">@code</span> null&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> null&#125; always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//因为该类是没有返回值的，所以返回null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Void <span class="title">getRawResult</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Requires null completion value.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setRawResult</span><span class="params">(Void mustBeNull)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements execution conventions for RecursiveActions.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//执行任务。内部调用compute()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        compute();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/RecursiveAction.html?spm=5176.100239.blogcont48736.5.SXYfZt" target="_blank" rel="noopener">RecursiveAction</a> 类与<a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/RecursiveTask.html" target="_blank" rel="noopener">RecursiveTask</a> 类非常类似。唯一的区别时 <code>RecursiveAction</code>类不会返回执行结果。用法与<code>RecursiveTask</code> 类一样。</p>
<hr>
<p>至此，有关<code>ForkJoinTask</code> 类大致分析完，下篇文章接着分析 <code>ForkJoinPool</code> 类</p>
<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://docs.oracle.com/javase/tutorial/essential/concurrency/forkjoin.html" target="_blank" rel="noopener">Fork/Join</a></p>
<p><a href="http://blog.csdn.net/yinwenjie/article/details/71524140" target="_blank" rel="noopener">多任务处理（12）——Fork/Join框架（基本使用）</a></p>
<p><a href="http://blog.csdn.net/yinwenjie/article/details/71915811" target="_blank" rel="noopener">多任务处理（13）——Fork/Join框架（解决排序问题）</a></p>
<p><a href="http://blog.csdn.net/yinwenjie/article/details/72520759" target="_blank" rel="noopener">多任务处理（14）——Fork/Join框架（要点1）</a></p>
<p><a href="http://blog.csdn.net/yinwenjie/article/details/72639297" target="_blank" rel="noopener">多任务处理（15）——Fork/Join框架（要点2）</a></p>
<p><a href="http://www.infoq.com/cn/articles/fork-join-introduction" target="_blank" rel="noopener">聊聊并发（八）——Fork/Join框架介绍</a></p>
<p><a href="http://zhangzemiao.com/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Fork-Join%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Fork/Join框架使用与分析</a></p>
<p><a href="http://blog.csdn.net/jsu_9207/article/details/78141682" target="_blank" rel="noopener">Java源码分析 - ForkJoinTask篇</a></p>
<p><a href="http://www.oracle.com/technetwork/articles/java/fork-join-422606.html" target="_blank" rel="noopener">Fork and Join: Java Can Excel at Painless Parallel Programming Too!</a></p>
<p><a href="http://gee.cs.oswego.edu/dl/papers/fj.pdf" target="_blank" rel="noopener">Doug Lea –《A Java Fork/Join Framework》</a></p>
<p><a href="http://kaimingwan.com/post/java/forkjoinpooljie-du" target="_blank" rel="noopener">ForkJoinPool解读</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://houlong123.github.io/2017/12/21/Fork-Join框架源码学习之ForkJoinTask学习/" data-id="cjcu8ctf6000paq0m9xzdm0zu" class="article-share-link">Teilen</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java并发/">java并发</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/25/Fork-Join框架源码学习之ForkJoinPool学习/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          Fork/Join框架源码学习之ForkJoinPool学习
        
      </div>
    </a>
  
  
    <a href="/2017/12/12/SynchronousQueue源码解析/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">SynchronousQueue源码解析</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mysql/">Mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dokuwiki部署/">dokuwiki部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java基础集合/">java基础集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发/">java并发</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发锁/">java并发锁</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java并发集合/">java并发集合</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/部署GitHub-Page/">部署GitHub Page</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mysql/" style="font-size: 12px;">Mysql</a> <a href="/tags/Spring/" style="font-size: 16px;">Spring</a> <a href="/tags/dokuwiki部署/" style="font-size: 10px;">dokuwiki部署</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/java/" style="font-size: 16px;">java</a> <a href="/tags/java基础集合/" style="font-size: 14px;">java基础集合</a> <a href="/tags/java并发/" style="font-size: 14px;">java并发</a> <a href="/tags/java并发锁/" style="font-size: 18px;">java并发锁</a> <a href="/tags/java并发集合/" style="font-size: 20px;">java并发集合</a> <a href="/tags/部署GitHub-Page/" style="font-size: 10px;">部署GitHub Page</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">June 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/25/hahh/">hahh</a>
          </li>
        
          <li>
            <a href="/2018/01/23/ArrayList源码学习/">ArrayList源码学习</a>
          </li>
        
          <li>
            <a href="/2018/01/19/java基础集合源码学习之AbstractList学习/">java基础集合源码学习之AbstractList学习</a>
          </li>
        
          <li>
            <a href="/2018/01/17/java基础集合源码学习之AbstractCollection学习/">java基础集合源码学习之AbstractCollection学习</a>
          </li>
        
          <li>
            <a href="/2018/01/08/CyclicBarrier源码学习/">CyclicBarrier源码学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 houlong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
  <a href="https://github.com/houlong123"><img style="position: absolute; top: 0; right: 0; border: 0; z-index: 1000;" src="https://camo.githubusercontent.com/e7bbb0521b397edbd5fe43e7f760759336b5e05f/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_green_007200.png"></a>
</body>
</html>
